# [返回](/)

# 杂七杂八知识点深入

## volatile

### JAVA内存模型简述

- 所有的变量都存储在主内存（Main Memory）中
- 每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比）
- 线程的工作内存中保存了被该线程使用的变量的主内存副本
- 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据
- 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成

### 基本特征

> 轻量级的同步机制
>
> 字节码层面添加ACC_VOLATILE修饰符
>
> ![image-20210714232608033](imgs\22.png)

- 保证可见性
- 不保证原子性
- 禁止指令重排

### 可见性

> JMM三大特性：可见性、原子性、有序性

**可见性**

一个线程对主内存中的共享变量进行修改，对其他线程是可见的，即，其他线程也可以“看见”这次修改

> 为什么需要工作内存？
>
> ![image-20210506203943876](imgs\1.png)
>
> cpu运算速度大于主内存*（内存条，硬件）*，为了进一步提高cpu效率，避免资源浪费，在cpu和主内存之间加入一、二、三级缓存和寄存器，这一部分就作为线程的工作内存，对于共享变量，线程写的过程：①拷贝一份到工作内存；②修改值；③写回主内存。线程读：①拷贝一份到工作内存；②读取

### 原子性

#### volatile原子性问题的解决方法

- 加synchronized

  > #### 关于同步的规定
  >
  > - 线程加锁前，需要清空自己的工作内存，确保从主内存读取共享变量
  > - 线程解锁前，需要将工作内存中共享变量的值刷新到主存
  > - 加解锁是同一把锁

- 原子变量

### 有序性

#### 指令重排

源代码→①编译器优化的重排→②指令并行的重排→③内存系统的重排→执行结果

处理器在进行重排序时必须要考虑指令之间的数据依赖性

**案例1**

```java
int x = 1;  // 语句1
int y = 2;  // 语句2
x = x + 5;  // 语句3
y = x * x;  // 语句4
```

正常顺序：1234

重排顺序1：2134

重排顺序2：1324

违背数据依赖性的顺序：3412、4321，......

**案例2**

```java
public class Test {
    static int a, b, x, y = 0;
    public static void main(String[] args) {
        new Thread(() -> {
            x = a;  // 1
            b = 1;  // 2
        }, "thread-1").start();
        new Thread(() -> {
            y = b;  // 3
            a = 2;  // 4
        }, "thread-2").start();
    }
}
```

期望顺序：1、3同时→2、4同时，x = 0，y = 0

重排顺序1：2、4同时→1、3同时，x = 2，y = 1

**案例3**

```java
public class Test {
    static int a = 0;
    static boolean flag = false;
    public static void main(String[] args) {
        new Thread(() -> {
            a = 1;  // 1
            flag = true;  // 2
        }, "thread-1").start();
        new Thread(() -> {
            if(flag) a = a + 5;
        }, "thread-2").start();
    }
}
```

期望顺序：1、2，a = 6

重排顺序：2、1，a = 5

**案例4**

new一个对象的过程

```tex
1. 创建对象的引用
2. 在堆中开辟一块内存空间
3. 在该内存空间生成一个对应对象
4. 令引用指向该内存空间
```

重排后：

```tex
1. 创建对象的引用
2. 在堆中开辟一块内存空间
3. 令引用指向该内存空间  //  此时引用!=null，但对象实际上并没有创建好
4. 在该内存空间生成一个对应对象
```

以上的几个案例，都是多线程环境下重排导致破坏了一致性的案例，这显然不是我们所期望的

#### volatile禁止指令重排

**JSR内存屏障**，又称内存栅栏（Memory Barrier），分为读屏障（Load）和写屏障（Store）是一个JVM层级的规范（不是cpu层级的具体实现，而是逻辑上的一种规范，具体实现要看jvm是怎么样实现的），有两个作用：①保证特定操作的执行顺序；②保证某些变量的内存可见性

①由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条内存屏障，则会告诉编译器和处理器，根据某种规则，不能和这条内存屏障指令重排序

②强制刷出各种CPU的缓存数据

**细节**

Load Barrier：①在指令前插入Load Barrier，可以让Load屏障前面的高速缓存中数据失效，强制从主内存加载数据；②不允许与读重排

Store Barrier：①在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见；②不允许与写重排

- LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕
- StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见
- LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕
- StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

**volatile的内存语义**

- 禁止重排序

- 可见性

volatile需要禁止重排序，即需要禁止以下所有重排序：[http://gee.cs.oswego.edu/dl/jmm/cookbook.html](http://gee.cs.oswego.edu/dl/jmm/cookbook.html)

![image-20210630020349572](imgs\2.png)

①普通读—volatile写；②普通写—volatile写；

③volatile读—普通读；④volatile读—普通写；⑤volatile读—volatile读；⑥volatile读—volatile写；

⑦volatile写—volatile读；⑧volatile写—volatile写

1. volatile写之前的操作，禁止重排序到volatile之后 

   `StoreStore → volatile写`

   禁止了②、⑥、⑧

2. volatile读之后的操作，禁止重排序到volatile之前 

   `volatile读 → LoadLoad → LoadStore`

   禁止了 ③、④、⑤、⑥；同时将缓存中数据失效，volatile读主存数据，实现volatile可见性

3. volatile写后volatile读，禁止重排序

   `volatile写 → StoreLoad → volatile读`；同时将缓存数据刷新至主存，实现volatile写可见性

   禁止了⑦

只剩下①没有满足，但实际上，①是可以重排序的，互不干涉，因此上述三个规则就满足了volatile的内存语义

**总结起来，JMM基于保守策略的十分悲观的JMM内存屏障插入策略：**

1. 在每个volatile写操作的前面插入一个StoreStore屏障
2. 在每个volatile写操作的后面插入一个StoreLoad屏障
3. 在每个volatile读操作的后面插入一个LoadLoad屏障
4. 在每个volatile读操作的后面插入一个LoadStore屏障

#### happens-before原则

[https://blog.csdn.net/qq_20221151/article/details/109055805?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link](https://blog.csdn.net/qq_20221151/article/details/109055805?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link)

> 是面向程序员的承诺：如果对于A、B，满足happens-before规则，即A happens-before B，那么在JMM的具体实现下，A操作的结果对B一定是可见的

是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，程序员可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性，保障，虚拟机可以对它们随意地进行重排序，需要程序员手动去添加同步措施，令其重新满足happens-before规则

![image-20211124014432859](imgs\51.png)

一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法

> 相当于JMM重排序规则对程序员视角的抽象，程序员只需要了解满足happens-before原则的代码是可以不用考虑并发安全问题的，而不需去考虑这些规则在底层具体怎样实现的，也不用自己去为满足规则的代码主动添加任何同步措施

**总结**

 什么是happens-before 原则？ 

- 它是 JMM 提供给开发人员的一个简单易于理解的一种强内存模型，只要操作A happens-before 操作B，那么 操作A 所造成的影响(比如修改数据)对操作B立刻可见，即使操作A和操作B不在同一个线程中
- 它是面向底层实现的一种弱内存模型，也给编译和处理器最大的宽松进行优化的可能，A happens-before B，并不意味着A实际在执行过程中一定在B之前，JMM的实现只需要满足结果一致即可

### 底层深究

#### Lock指令

![image-20210714201054781](imgs\17.png)

volatile到最低层，使用的是lock addl指令

> synchronized是lock cmpxchg

> hostspot实现用的是lock指令，最简单粗暴的，实际上x86本身有内存屏障的指令sfence和mfence

其中，addl是一条空指令（往寄存器加个0），真正起作用的是lock

lock的作用：

- 将当前处理器对应的缓存内容刷新到内存
- 令其他处理器对应的缓存失效
- 令有序的指令无法越过此内存屏障

#### MESI缓存一致性协议

[相关链接：volatile与MESI](https://www.zhihu.com/question/296949412?sort=created)

> 缓存一致性协议的一种

> MESI 只是缓存一致性协议，每种语言都有不同的对 MESI 的实现方式，在 Java 中是借助了 volatile 关键字来实现的，也就是说 volatile 关键字的底层原理是使用 MESI 来保证可见性

每次从内存往缓存读取的时候，多数是按块读取（根据内存总线宽度），这一块叫做缓存行（Cache Line，大多数是64字节）

> 为什么读一块？是根据程序局部性原理，可以提高效率
>
> **程序局部性原理**：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性
>
> **时间局部性：**被引用过一次的存储器位置在未来会被多次引用（通常在循环中）
>
> **空间局部性：**如果一个存储器的位置被引用，那么将来他附近的位置也会被引用

读行内某一个数据时，会把整行放到缓存，修改了行内某个数据，需要通知其他cpu，这就要根据MESI协议。线程之间，需要保持**缓存行**的一致性

**MESI代表缓存行四种状态**：M-Modified，被修改了；E-Exclusive，独占；S-Shared，共享；Invalid，失效

**伪共享问题**

```java
public class Testt {
    static int COUNT = 10000000;
    public static T[] arr = new T[2];
    static {
        arr[0] = new T();
        arr[1] = new T();
    }
    public static void main(String[] args) {
        long start = System.currentTimeMillis(), end;
        new Thread(() -> {
            for(int i = 0; i < COUNT; i++){
                arr[0].x = i;
            }
        }).start();
        new Thread(() -> {
            for(int i = 0; i < COUNT; i++){
                arr[1].x = i;
            }
        }).start();
        while(Thread.activeCount() > 2) Thread.yield();
        end = System.currentTimeMillis();
        System.out.println((end - start) + "ms");
    }
}
class T{
    public volatile long x = 0;
}
```

两个线程分别修改T类型数组arr的第一个元素和第二个元素，运行时间：![image-20210714214242365](imgs\18.png)

![image-20210714214210123](imgs\19.png)

***勘误：length应该是4个字节，这里画成了8个字节***

A线程修改该缓存行内的变量arr[0]后，按照缓存一致性协议，B需将该缓存行置为失效（S→I），A将最新缓存行数据写回内存。
B的l1缓存中没有该缓存行，也就是miss了，需重新从内存中加载包含变量arr[1]的缓存行数据，并放置缓存。如果B修改变量arr[1]，需要A将B的缓存行置为失效，B将最新缓存写回内存
总结来说，就是多核多线程并发场景下，多核要操作的不同变量处于同一缓存行，某cpu更新缓存行中数据，并将其写回缓存，同时其他处理器会使该缓存行失效，如需使用，还需从内存中重新加载。这对效率产生了较大的影响

**作出如下更改**

```java
class T{
    public volatile long p1, p2, p3, p4, p5, p6, p7;
    public volatile long x = 0;
}
```

![image-20210714220141111](imgs\20.png)

可以看到，arr[0]和arr[1]，一定不处于一个缓存行，所以A修改缓存行后，B不会令缓存行失效，B也就不用从内存重新加载了，这样的话，不会相互通知，效率就提升了，运行时间：![image-20210714221751372](imgs\21.png)

[链接](https://zhuanlan.zhihu.com/p/124974025)

> JDK8中，可通过设置`-XX:-RestrictContended`，并添加@sun.misc.Contended注解，自动实现缓存行独占
>
> 新jdk版本中迁移到了@jdk.internal.vm.annotation.Contended，且不建议用户自己使用，如果要使用
>
> 可在在Setting - Build,Execution,Deployment - Compiler - Java Compiler - Override compiler parameters per-module中增加如下设置：
>
> ```csharp
> --add-exports=java.base/jdk.internal.vm.annotation=ALL-UNNAMED 
> ```
>
> Disruptor高性能队列，就是基于伪共享问题做出的改进，用到了补齐技术

### DCL单例模式

```java
class Singleton{
    /**
     * 为什么要加volatile？
     * 因为可能出现这种情况，线程A先进，判断为null，开始创建INSTANCE指向的对象
     * 此时由于指令重排序，INSTANCE可能已经指向堆中某内存空间，不为null了，但该空间上的对象还没有完全创建好
     * 此时B进，判断不为null了，结果返回了一个还未完全创建好的对象
     */
    private static volatile Singleton INSTANCE = null;
    private Singleton(){}
    public static Singleton getInstance(){
        if(INSTANCE == null){
            synchronized (Singleton.class){
                if(INSTANCE == null){
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

> 其他的单例还有饿汉、枚举、静态内部类等等

## CAS

### 基本特征

Compare And Swap：比较并交换

```java
AtomicInteger i = new AtomicInteger(5);
i.compareAndSet(5, 2020);  // true，期望值匹配，交换成功
i.compareAndSet(5, 2021);  // false，期望值不匹配，交换失败
System.out.println(i);  // 2020
```

### 底层原理

针对例子：

```java
AtomicInteger atomicInteger = new AtomicInteger();
atomicInteger.getAndIncrement();
```

底层并不是用synchronized实现的，为什么？来看源码

![image-20210630164854034](imgs\3.png)

其中U：`private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();`是一个Unsafe对象

VALUE：内存偏移量，value域的内存地址

value：AtomicInteger的底层存储，对所有线程可见

![image-20210630165645725](imgs\4.png)

**Unsafe类是什么？**

rt.jar(*runtime*)/sun/misc包下，JVM runtime的jar包中的底层类。Java方法无法访问底层，需要通过native方法，Unsafe相当于提供了一个后门，可以通过该类相当于C的指针一样直接操作特定内存的数据

**CAS**

调用Unsafe的方法，JVM会帮我们实现CAS的汇编指令

**CAS：Compare-And-Swap，是一条CPU并发原语，完全依赖于硬件实现原子操作，执行不允许被打断，因此不会造成数据不一致**

再看getAndAddInt：

![image-20210630171228313](imgs\5.png)

- 首先，getIntVolatile获取当前AtomicInteger对象的value处的值是多少，是native方法

- 接着不断循环调用weakCompareAndSetInt，o加offset确定value的内存地址，v为期望值，v+delta是要更新的值，这就是一个典型的CAS操作（不是native方法，但点进去是`return compareAndSetInt(o, offset, expected, x);`是一个native方法）

- 先获取内存地址处的值作为期望值，再去调用weakCompareAndSetInt，访问内存地址的值，如果与工作内存中的期望值匹配失败，则不做处理；如果匹配成功，则更新。不断循环该过程，称为自旋

这样就可以回答上面的问题：为什么getAndIncrement底层并不是用synchronized实现的？**因为synchronized保证了一致性，但只有一个线程能运行，并发性下降；CAS保证了一致性，又提高了并发性。具体是用Unsafe类+CAS思想+自旋来实现的**

> Unsafe的CAS类型方法是native方法，实现位于unsafe.cpp当中
>
> ```cpp
> UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
> UnsafeWrapper("Unsafe_CompareAndSwapInt");
> oop p = JNIHandles::resolve(obj);
> jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
> return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
> UNSAFE_END
> ```
>
> Atomic::cmpxchg(compare x change)：x为即将更新的值，addr为地址，e为原值
>
> 如果是 e，那就把它更新为 x，返回true，如果不是 e，那就什么也不做，并且返回false
>
> 补充：Atomic::cmpxchg这个方法的实现放在hotspot下的os_cpu包中，说明这个方法的实现和操作系统、CPU都有关系（具体是汇编的LOCK_IF_MP：MP即为MultiProcessor），以linux的X86处理器的实现为例，是由cmpxchg实现的，判断若为多处理器，则为lock  cmpxchg，lock锁住北桥信号（不采用锁总线的方式），多个cpu时，只能有一个cpu来进行CAS
>
> ![image-20210713161205108](imgs\7.png)
>
> ![img](imgs\15.png)
>
> 实际上看看源码
>
> ![img](imgs\16.png)
>
> 是cmpxchgl，在汇编语言中，①b是byte的意思，意味着操作数大小为1字节，相当于c语言的char类型；②w是word的意思，意味着操作数大小为2字节；③l是long的意思，意味着操作数大小为4字节，相当于c语言的long int类型。所以上面我就直接说成是cmpxchg指令

#### 总结

CAS是CPU并发原语，靠底层硬件实现，是原子操作

有三个操作数：V-内存真实值，A-期望值，B-要更新的值

A与V一致时，V处更新为B；否则不做处理

### CAS缺点

1. 循环时间长，开销大，消耗cpu资源，如果CAS持续不成功，CPU开销较大
2. 只能保证一个共享变量的原子操作（比如atomicInteger这一个变量的线程安全，是可以保证的，但一段代码就不行了）
3. **ABA问题**

#### ABA问题

线程1、2同时读V处的值为A，此时线程1挂起，线程2将A改成了B，又改回了A，这个过程对于线程1是未知的，线程1顺利完成CAS，但实际上整个流程是不对的，这就是ABA问题

#### 原子引用

```java
AtomicReference<User> atomicReference = new AtomicReference<>();
User u1 = new User(20, "u1");
User u2 = new User(22, "u2");
atomicReference.set(u1);
atomicReference.compareAndSet(u1, u2);  //  true
System.out.println(atomicReference.get());  //  u2
atomicReference.compareAndSet(u1, u2);  //  false
System.out.println(atomicReference.get());  //  u1
```

#### 时间戳原子引用

> 新增修改版本号机制，记录更改的操作

如果某个线程发现自己的共享变量版本号落后于真实值，则说明已经有其他线程改过了

#### ABA问题的解决

ABA案例：

```java
static AtomicInteger atomicInteger = new AtomicInteger(100);
public static void main(String[] args) {
    new Thread(() -> {
        atomicInteger.compareAndSet(100, 101);  // AB
        atomicInteger.compareAndSet(101, 100);  // BA
    }).start();
    new Thread(() -> {
        try {
            TimeUnit.SECONDS.sleep(1);  // 等待线程1完成ABA
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        atomicInteger.compareAndSet(100, 2021);
    }).start();
    while (Thread.activeCount() > 2);
    System.out.println(atomicInteger.get());  // 2021
}
```

ABA解决：

```java
static AtomicStampedReference<Integer> atomicStampedReference
        = new AtomicStampedReference<>(100, 1);
public static void main(String[] args) {
    new Thread(() -> {
        atomicStampedReference.compareAndSet(100, 101,
                1, 2);
        atomicStampedReference.compareAndSet(101, 100,
                2, 3);
    }).start();
    new Thread(() -> {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        atomicStampedReference.compareAndSet(100, 2021,
                1, 2);  //  第三个参数是期望版本号（时间戳），第四个参数为将要进行的版本号更新
    }).start();
    while(Thread.activeCount() > 2);
    System.out.println(atomicStampedReference.getReference());  // 100
    //  atomicStampedReference.getStamp() == 3
}
```

## 集合类不安全

### 快速失败机制

java并发修改异常：java.util.ConcurrentModificationException

> ps：对错误处理的处理思维
>
> 故障现象→导致原因→解决方案→优化建议

iterator迭代时，对list的修改，导致modCount != expectedModCount，抛出异常

> 解决方案：
>
> - CopyOnWriteArraylist

### 安全失败机制

迭代器迭代时复制一个容器的副本，在副本上进行迭代，因此对原本容器的修改不会导致异常

####  CopyOnWriteArrayList

**底层实现：**private transient volatile Object[] array;

**add方法：**

```java
public boolean add(E e) {
    synchronized (lock) {
        Object[] es = getArray();
        int len = es.length;
        es = Arrays.copyOf(es, len + 1);
        es[len] = e;
        setArray(es);
        return true;
    }
}
```

可以看出，写时复制

**写时复制，读写分离**

> java.util：快速失败
>
> java.concurrent：安全失败

### HashMap不安全

JDK 1.7：由于头插法导致的扩容时的循环链表、数据丢失，以及put时的数据覆盖，即覆盖新值却不返回原值

> 为啥采用头插法？因为在1.7中认为新插入的元素将会更频繁地被访问，为热点数据

JDK 1.8：利用尾插法解决了扩容时的循环链表和数据丢失问题，遗留put时的数据覆盖问题

## CountDownLatch和CyclicBarrier区别

> 以游戏启动场景为例，需要五个玩家集齐后系统启动
>
> ```java
> CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> System.out.println("game start"));
> for (int i = 0; i < 5; i++) {
>     final int ii = i;
>     new Thread(() -> {
>         System.out.println("player " + ii + " ready");
>         try {
>             cyclicBarrier.await();
>         } catch (InterruptedException | BrokenBarrierException e) {
>             e.printStackTrace();
>         }
>     }).start();
> }
> ```
>
> 某个玩家ready后，线程阻塞，需要等待其他玩家一起ready，最后进入系统
>
> ```java
> CountDownLatch latch = new CountDownLatch(5);
> for (int i = 0; i < 5; i++) {
>     final int ii = i;
>     new Thread(() -> {
>         System.out.println("player " + ii + " ready");
>         latch.countDown();
>     }).start();
> }
> latch.await();
> System.out.println("game start");
> ```
>
> 系统线程阻塞，只有所有玩家完成ready，才启动

看出区别了吗？

对于CyclicBarrier

1. 阻塞等待的是所有参与线程，参与线程全部到达barrier时，进行终极任务
2. 具有**重复利用性**，可以执行多次终极任务

而对于CountDownLatch

1. 参与线程不会阻塞，而是终极任务的线程阻塞，等待其他所有线程手动countDown，不影响自身执行
2. 终极任务只能执行一次

> 相当于，一个饭局上，CountDownLatch是每个人吃完后可以走人，只不过跟大家说一声“我吃完了”，吃饭人数减一，减为0时进行结账；CyclicBarrier是每个人吃完后，必须等待其他人都吃完，在结账，存在状态上的**一致性**

> 注意：源码中都是进行自减操作，有些地方说Barrier自加，这是不对的

## 生产者消费者的三个版本

1. sychronized、wait、notify版本

   ```java
   public class Testt {
       public static void main(String[] args) {
           SharedData data = new SharedData();
           new Thread(() -> {
               for (int i = 0; i < 5; i++) {
                   try {
                       data.decrement();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }, "Consumer").start();
           new Thread(() -> {
               for (int i = 0; i < 5; i++) {
                   try {
                       data.increment();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }, "Producer").start();
       }
   }
   class SharedData{
       private int number;
       public synchronized void increment() throws InterruptedException {
           while (number != 0){
               wait();
           }
           number++;
           System.out.println(Thread.currentThread().getName() + " put, number = " + number);
           notifyAll();
       }
       public synchronized void decrement() throws InterruptedException {
           while (number == 0){
               wait();
           }
           number--;
           System.out.println(Thread.currentThread().getName() + " take, number = " + number);
           notifyAll();
       }
   }
   ```

   > 注意避免**虚假唤醒**，即判断时要用while，否则wait的线程拿到锁之后如果被唤醒，就直接往下走，而不会recheck，如果是两个卡住的consumer被唤醒，可能导致number为负数

2. lock、await、signal版本

   ```java
   public class Testt {
       public static void main(String[] args) {
           SharedData data = new SharedData();
           new Thread(() -> {
               for (int i = 0; i < 5; i++) {
                   try {
                       data.decrement();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }, "Consumer").start();
           new Thread(() -> {
               for (int i = 0; i < 5; i++) {
                   try {
                       data.increment();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }, "Producer").start();
       }
   }
   class SharedData{
       private int number;
       private Lock lock = new ReentrantLock();
       private Condition condition = lock.newCondition();
       public void increment() throws InterruptedException {
           lock.lock();
           while (number != 0){
               condition.await();
           }
           number++;
           System.out.println(Thread.currentThread().getName() + " put, number = " + number);
           condition.signalAll();
           lock.unlock();
       }
       public void decrement() throws InterruptedException {
           lock.lock();
           while (number == 0){
               condition.await();
           }
           number--;
           System.out.println(Thread.currentThread().getName() + " take, number = " + number);
           condition.signalAll();
           lock.unlock();
       }
   }
   ```

3. 阻塞队列版本

   ```java
   class SharedData{
       private BlockingQueue<Integer> queue = new SynchronousQueue<>();
       public void increment() throws InterruptedException {
           queue.put(1);
           System.out.println(Thread.currentThread().getName() + " put");
       }
       public void decrement() throws InterruptedException {
           int i = queue.take();
           System.out.println(Thread.currentThread().getName() + " take " + i);
       }
   }
   ```

## 死锁

多个线程互斥争夺共享资源，从而导致的一种互相等待的情况

四个条件：① 互斥；② 不可剥夺；③ 请求保持；④循环等待

### 编码实现

```java
Object o1 = new Object(), o2 = new Object();
new Thread(() -> {
    synchronized (o1){
        System.out.println(Thread.currentThread().getName() + " working");
        synchronized (o2){
            System.out.println(Thread.currentThread().getName() + " end");
        }
    }
}).start();
new Thread(() -> {
    synchronized (o2){
        System.out.println(Thread.currentThread().getName() + " working");
        synchronized (o1){
            System.out.println(Thread.currentThread().getName() + " end");
        }
    }
}).start();
```

### 问题定位

- jps：查看进程
- jstack：查看栈运行信息

步骤：① jps搜索进程号；② jstack pid查看相关信息

![image-20210903094219037](imgs\47.png)

## Java线程

### Java-1：1的内核线程模型

[https://blog.csdn.net/woshilijiuyi/article/details/88874783](https://blog.csdn.net/woshilijiuyi/article/details/88874783)

[https://www.cnblogs.com/tong-yuan/p/11626491.html](https://www.cnblogs.com/tong-yuan/p/11626491.html)

### 状态转换

Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是： 

- 新建（New）：创建后尚未启动的线程处于这种状态
- 运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间 
- 无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态： 
  - 没有设置Timeout参数的Object::wait()方法； 
  - 没有设置Timeout参数的Thread::join()方法； 
  - LockSupport::park()方法。 

- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  - Thread::sleep()方法； 
  - 设置了Timeout参数的Object::wait()方法； 
  - 设置了Timeout参数的Thread::join()方法； 
  - LockSupport::parkNanos()方法； 
  - LockSupport::parkUntil()方法。 

- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

上述6种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图所示

![image-20211124015746006](imgs\52.png)

## 线程池

### 阻塞队列

#### 作用

不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了

在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而
这会给我们的程序带来不小的复杂度

线程池的底层实现

#### 使用

![image-20210902095120795](imgs\44.png)

![image-20210902095504888](imgs\45.png)

### 线程池

#### 继承关系

![image-20210902095120795](imgs\46.png)

常用的有：

```java
Executors.newFixedThreadPool(n);      // 一池固定个线程
Executors.newSingleThreadExecutor();  // 一池一个线程
Executors.newCachedThreadPool();      // 池内线程数根据工作负载决定，如果若干个线程处理不过来，会分配更多线程
Executors.newScheduledThreadPool();   // 延迟任务，过了时间后才能take
Executors.newWorkStealingPool();      // 实现工作窃取的线程池（双端队列思想）
```

#### 七大参数

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    return new Executors.FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                    0L, TimeUnit.MILLISECONDS,
                    new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
            60L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());
}
```

可以看到，对于这三种常用线程池，底层都是采用ThreadPoolExecutor的构造器创建的

> 其中，newSingleThreadExecutor中，ThreadPoolExecutor作为参数传入代理类FinalizableDelegatedExecutorService，里面重写了finalize方法，对ThreadPoolExecutor进行了shutdown。也就是说自己没有手动shutdown的话，会在gc阶段调用finalize方法时主动shutdown

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

- int corePoolSize：线程池中的常驻核心线程数

  > 线程池创建后，安排池中的线程去执行任务
  >
  > 当线程到达corePoolSize后，新来的任务被放入任务队列中

- int maximumPoolSize：线程池能够容纳同时执行的最大线程数

  > 线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务；如果已经到达maximumPoolSize，则会拒绝新任务并抛出RejectedExecutionException

- long keepAliveTime：多余的空闲线程的存活时间

  > 线程池中的线程数大于corePoolSize时，空闲线程在keepAliveTime后会被销毁，直到线程数回到corePoolSize

- TimeUnit unit：keepAliveTime的单位

- BlockingQueue\<Runnable> workQueue：任务队列

  > 存放被提交但仍未执行，处于等待的任务

- ThreadFactory threadFactory：生成线程池中工作线程的线程工厂

  > 工厂模式生成线程，一般采用默认工厂

- RejectedExecutionHandler handler：拒绝策略

  > 到达maximumPoolSize，则会拒绝新任务，有四类拒绝策略

#### 四大拒绝策略

- AbortPolicy（默认）：直接抛出RejectExecutionException

- CallerRunsPolicy：“Caller Run”，调用者运行，既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者

  > ```java
  > public static void main(String[] args) {
  >     ExecutorService service = new ThreadPoolExecutor(5, 5,
  >                                                      100L, TimeUnit.SECONDS,
  >                                                      new ArrayBlockingQueue<>(5),
  >                                                      Executors.defaultThreadFactory(),
  >                                                      new ThreadPoolExecutor.CallerRunsPolicy());
  >     for (int i = 0; i < 50; i++) {
  >         service.execute(() -> System.out.println(Thread.currentThread().getName()));
  >     }
  > }
  > ```
  >
  > 比如这里，任务会回退给main线程处理

- DiscardOldestPolicy：抛弃等待队列中等待最久的任务，并把新任务放进队列并尝试再次提交

- DiscardPolicy：直接丢弃任务，如果允许任务丢失，这是最好的策略

#### 为什么不建议使用Executors静态工厂创建线程池？

以三个常用的为例：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    // 用的是无界队列，会无限扩张
    // 因此maximumPoolSize成了无效参数，队列不断扩张，但常驻线程数不超过corePoolSize
    // keepAliveTime和unit也成了无效参数
    return new ThreadPoolExecutor(nThreads, nThreads,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    // 理由同上
    return new Executors.FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                    0L, TimeUnit.MILLISECONDS,
                    new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newCachedThreadPool() {
    // 直接分配线程，等待队列不放，可能造成线程数过多
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
            60L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());
}
```

#### 合理配置

- cpu密集型任务：需大量计算，cpu全速运算，不阻塞

  令线程数 = cpu核数 + 1

- io密集型任务：并不是一直在执行任务，常常处于阻塞，cpu空闲， 所以应配置尽可能多的线程

  比如：cpu核数 * 2

  参考公式：cpu核数 / （1 - 阻塞系数）*阻塞系数范围0.8~0.9*
  
- [动态修改线程池]([如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。 (qq.com)](https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect))

## 锁理论

### 公平锁&非公平锁

- 公平锁：先来后到，按照申请锁的顺序获取锁
- 非公平锁：不按顺序，可能造成线程饥饿或优先级反转，吞吐量>公平锁

### 可重入锁（递归锁）

锁的操作粒度是“线程”而不是“调用”，即允许一个线程多次调用，而不是只允许一次调用

同步方法里面可以访问持有同一把锁的同步方法，且该方法自动获取锁，防止死锁

### 自旋锁

线程获取不到锁不会阻塞，而是会不断循环去申请锁，好处是减少上下文切换，缺点是消耗cpu资源

```java
class MySpinLock {
    final private AtomicReference<Thread> atomicReference = new AtomicReference<>();
    public void myLock(){
        int count = 0;
        do{
            if(count++ == 0) System.out.println(Thread.currentThread().getName() +
                    " is trying to get spin lock");
        }
        while(!atomicReference.compareAndSet(null, Thread.currentThread()));
    }
    public void myUnlock(){
        atomicReference.compareAndSet(Thread.currentThread(), null);
        System.out.println(Thread.currentThread().getName() + " unlock");
    }
    public static void main(String[] args) {
        MySpinLock lock = new MySpinLock();
        new Thread(() -> {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("this is " + Thread.currentThread().getName());
            lock.myUnlock();
        }).start();
        new Thread(() -> {
            lock.myLock();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("this is " + Thread.currentThread().getName());
            lock.myUnlock();
        }).start();
    }
}
```

![image-20210701163728005](imgs\6.png)

Thread-0先拿到自旋锁，等待五秒，期间Thread-1不断自旋并CAS，直到Thread-0解锁，Thread-1才能拿到锁执行

### 读写锁

读时共享，写时独占，采用state的高16位和低16位分别作读、写锁

## 强/软/弱/虚引用

### 强引用

普通引用，OOM也不会回收

### 软引用

内存不足时，软引用会被回收，主要用于不是很重要的数据的缓存

```java
Object ptr = new Object();
SoftReference<Object> softReference = new SoftReference<>(ptr);
```

![image-20210715162227821](imgs\25.png)

> 首先，令-Xmx20m，堆内存大小设置为20m
>
> ```java
> SoftReference<byte[]> b = new SoftReference<>(new byte[1024 * 1024 * 10]);  // 10M数组
> System.gc();
> System.out.println(b.get());  // 通过get获取引用
> Thread.sleep(3000);
> System.gc();
> System.out.println(b.get());
> byte[] b2 = new byte[1024 * 1024 * 15];  // 15M数组
> System.gc();
> System.out.println(b.get());
> ```
>
> 运行结果：![image-20210715110504839](imgs\24.png)
>
> 可以看出，第二次new数组的时候，堆空间不够了，软引用指向的数组被回收了

> 使用场景：图片缓存
>
> ```java
> Image image = new Image();
> HashMap<String, SoftReference<Image>> imageCache = new HashMap<>(){{
>     put("D:/x/x/x.jpg", new SoftReference<>(image));
> }};
> ```

### 弱引用

gc直接回收

```java
Object ptr = new Object();
WeakReference<Object> weakReference = new WeakReference<>(ptr);
```

![image-20210715162548403](imgs\26.png)

> ```java
> WeakReference<Object> ptr = new WeakReference<>(new Object());
> System.out.println(ptr.get());
> System.gc();
> System.out.println(ptr.get());
> ```
>
> 运行结果：![image-20210715113302462](imgs\27.png)
>
> 可以看到，gc直接将弱引用指向的对象回收了

> 主要用途：ThreadLocal

#### WeakHashMap

```java
WeakHashMap<Integer, String> map = new WeakHashMap<>();
// 大于127，使之不指向IntegerCache，能回收
Integer i = 128;
map.put(i, "hashmap");
i = null;
System.gc();
System.out.println(map);  // 被回收了
```

```java
Entry(Object key, V value,
      ReferenceQueue<Object> queue,
      int hash, Entry<K,V> next) {
    /**
     * public WeakReference(T referent, ReferenceQueue<? super T> q) {
           super(referent, q);
       }
     */
    // 构造时将key创建为弱引用
    super(key, queue);
    this.value = value;
    this.hash  = hash;
    this.next  = next;
}
```

### 虚引用

一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

gc时直接回收，必须与ReferenceQueue配合使用，回收后将虚引用放进队列，出队后完全销毁对象，一般起到通知对象被销毁的作用，常用于堆外内存管理

![image-20210715163429807](imgs\28.png)

> 在之前进行网络传输时，JVM发送数据到网络，要经历：数据→JVM→复制到JVM堆（用户态）→复制到操作系统内存（堆外内存）（内核态）→网卡
>
> NIO之后，提供了直接操作堆外内存的对象，但当这一对象被gc回收之后，它管理的堆外内存就会造成内存泄漏
>
> 因此，用弱引用指向该对象，对象回收后进入队列，发送通知，此时便可以进行回收堆外内存操作，相当于一种**通知机制**

> ```java
> final static ReferenceQueue<Object> QUEUE = new ReferenceQueue<>();
> public static void main(String[] args)  {
>     new Thread(() -> {
>         Object something = new Object();
>         PhantomReference<Object> ptr = new PhantomReference<>(something, QUEUE);
>         something = null;  // 指向原object对象只有一个虚引用了，而没有something强引用
>         System.gc();
>     }).start();
>     while (true){
>         Object o = QUEUE.poll();
>         if(o != null){
>             System.out.println("something被回收时间: " + LocalDateTime.now());
>             break;
>         }
>     }
> }
> ```

## ThreadLocal源码解析

### 使用

```java
public static void main(String[] args) {
    ThreadLocal<Integer> threadLocalVar = new ThreadLocal<>();
    threadLocalVar.set(1);
    foo(threadLocalVar);
    new Thread(() -> foo(threadLocalVar), "A").start();
    new Thread(() -> {
        threadLocalVar.set(2);
        foo(threadLocalVar);
    }, "B").start();
}
public static void foo(ThreadLocal<Integer> threadLocal){
    System.out.println(Thread.currentThread().getName() + "'s threadLocalVar: " + threadLocal.get());
}
```

输出结果：

![image-20210929020532719](imgs\48.png)

说明threadLocal在线程之间实现了隔离

**用途**

mysql的连接、spring的事务等等

### 源码解析

以上面的共享变量threadLocalVar为例

#### get

```java
public T get() {
    // 首先令t为当前线程
    Thread t = Thread.currentThread();
    // 通过getMap拿到某个map
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 从map里面拿出一个Entry的结构
        // this为ThreadLocal变量，即上面的threadLocalVar
        // 猜测，通过threadLocalVar为key，拿到map中的一条记录
        ThreadLocalMap.Entry e = map.getEntry(this);
        // 如果拿到，则返回
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    // 如果map为null或map中没有threadLocalVar为key的记录，进入该方法
    return setInitialValue();
}
```

看看getMap方法：

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

我们知道，t是当前线程，也就是说，该方法返回当前线程内的一个成员变量，叫做threadLocals

点开Thread类发现：

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```

```java
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            // 调用父类构造方法，令k为一个弱引用
            super(k);
            value = v;
        }
    }
    ...
    private Entry[] table;
    ...
}
```

ThreadLocalMap是一个类似于HashMap的结构，底层由Entry数组构成，其中的Entry继承一个弱引用

即：

![image-20210929020253057](imgs\49.png)

get方法就是首先找到线程私有的threadLocals，再以共享变量threadLocalVar为key，拿出对应的map里面的value，这自然也是私有的

再看看setInitialValue()方法，如果map为null或map中没有threadLocalVar为key的记录，进入该方法

```java
private T setInitialValue() {
    // 设定初始value为null
    // 如果map不为null，但map中没有threadLocalVar为key的记录，则插入一条threadLocalVar→null
    // 为null，为线程创建map
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    // 返回null
    return value;
}

protected T initialValue() {
    return null;
}
```

也就是说，如果get之前没有set，则插入一条初始值为null的记录

因此，针对上面三个线程，有：

![image-20210929022051837](imgs\50.png)

因此，实现了线程隔离

> 如果外层的threadLocalVar一直不指向null，则GC后这些key也不会变成null

#### set

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

主要是调用map的set方法

```java
private void set(ThreadLocal<?> key, Object value) {
    // 看过hashmap源码一定对这段很熟悉，不多介绍了
	Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            // 该方法比较复杂，注释说，如果遍历时遇到为null的k
            // 则调用该方法直接用将要插入的记录去替代该处，并return
            // 不管原map中key是否存在
            replaceStaleEntry(key, value, i);
            return;
        }
    }
	// 插入新记录
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 如果清槽失败或超阈值，则rehash（方法是扩容成两倍，跟hashmap类似）
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

cleanSomeSlots

```java
private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        // 如果遇到Entry不为空，但key为null的时候，则移除该Entry
        if (e != null && e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n >>>= 1) != 0);
    return removed;
}
```

也就是说，set方法会在插入新记录之后清槽，将那些key为null的Entry清理掉

而get方法在没有找到后会调用setInitialValue()插入一条threadLocalVar→null，会调用map.set(this, value)，也会清槽

#### hash



### 内存泄漏

有两处可能内存泄漏的地方

1. 假设threadLocals的key为强引用，那么当线程插入某记录后，线程外部程序，令threadLocal变量指向null，意欲回收，然而只要线程不死，里面的强引用一直存在，threadLocal变量永远回收不了。因此在map内部要用弱引用指向它，防止threadLocal变量发生内存泄漏

2. threadLocal指向弱引用，会在gc后被回收，这时线程的map里面可能存在null→value这样的entry，也就是说，entry不为null，但实际上永远访问不到，因此发生了entry内存泄漏

   因此，threadLocal在set中提供了cleanSomeSlots的方法清槽，同时，get方法在没获取到的时候，也会进行清槽。然而我们在操纵线程时，并不一定会在期望的时间内调用这两个方法，也就是说，直到调用这两个方法之前，内存泄露的问题一直都存在

   因此，在线程内使用完threadLocal变量之后，记得主动去调用它的remove()方法，移除key为null的entry

## 对象内存布局

针对于堆中的对象，分成几个部分，以下面为例（64位系统）

```java
class Student{
    int age;
    String name;
}
```

new Student()

![image-20210713165149246](imgs\8.png)

- 对象头

  - markword：8字节
    - 锁信息
    - GC信息
    - hashCode
  - klass pointer（instanceOopDesc）：指向所属类的方法区内的类元信息（instanceKlass）地址
    - 开启指针压缩：4字节（默认开启）
    - 不开启指针压缩：8字节
  - length：4字节，数组特有

- 实例数据

  - instance data：类成员变量等，本例中为age的4字节 + name引用的4个字节（开启指针压缩：-XX:+UseCompressedOops）

- 对齐填充

  - padding：64位虚拟机下，填充成8个字节的倍数

    > HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍

**实例**

利用工具：openjdk的jol，查看内存布局

```java
Object o = new Object();
System.out.println(ClassLayout.parseInstance(o).toPrintable());
```

![image-20210713204806342](imgs\9.png)

## synchronized

- 保证原子性

- 保证可见性

  > JMM关于synchronized的两条规定：
  >
  > 1. 线程解锁前，必须把共享变量的最新值刷新到主内存中
  > 2. 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值

- 保证有序性

  > as-if-serial：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会改变
  >
  > 编译器、runtime和处理器都必须遵守as-if-serial语义，因此不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果

  > **为什么synchronized无法禁止指令重排，却能保证有序性**
  >
  > - 最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样
  >
  > - 但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义
  >
  > - synchronized是一种排他的、可重入的锁
  >
  > - 所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。
  >
  > - synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是单线程，因为有as-if-serial语义保证，单线程的有序性就天然存在了。

- 保证可重入性

  > synchronized锁对象（Monitor）中包含一个计数器（recursion变量）用于记录重入次数，同步块内代码每执行完一次就减一，减为0时就释放锁

- 保证不可中断

  > 线程通过synchronized获得锁之后，其他同样方式取锁的线程会阻塞等待，且这个过程是无法中断的
  >
  > ```java
  > public static void main(String[] args) throws InterruptedException {
  >     Runnable run = () -> {
  >         synchronized (Object.class){
  >             try {
  >                 System.out.println(Thread.currentThread().getName() + " start");
  >                 Thread.sleep(999999);
  >                 System.out.println(Thread.currentThread().getName() + " end");
  >             } catch (InterruptedException e) {
  >                 e.printStackTrace();
  >             }
  >         }
  >     };
  >     Thread t1 = new Thread(run, "t1");
  >     Thread t2 = new Thread(run, "t2");
  >     t1.start();
  >     Thread.sleep(100);
  >     t2.start();
  >     System.out.println("main线程尝试中断t2");
  >     t2.stop();
  > }
  > ```
  >
  > 实际上，普通的Lock也是不可中断的，但lockInterruptibly可以
  >
  > ```java
  > static ReentrantLock lock = new ReentrantLock();
  > public static void main(String[] args) throws InterruptedException {
  >     Runnable run = () -> {
  >         try {
  >             lock.lockInterruptibly();
  >             System.out.println(Thread.currentThread().getName() + " start");
  >             Thread.sleep(999999);
  >             System.out.println(Thread.currentThread().getName() + " end");
  >         } catch (InterruptedException e) {
  >             e.printStackTrace();
  >         }finally {
  >             lock.unlock();
  >         }
  >     };
  >     Thread t1 = new Thread(run, "t1");
  >     Thread t2 = new Thread(run, "t2");
  >     t1.start();
  >     Thread.sleep(100);
  >     t2.start();
  >     System.out.println("main线程尝试中断t2");
  >     t2.interrupt();
  > }
  > ```

### 底层原理

字节码层级，monitorenter方法进入同步块，monitorexit出同步块（正常退出、异常退出）

> javac为同步代码块添加了一个隐式的try-finally，在finally中会调用`monitorexit`命令释放锁

> 同步方法的字节码是增加了一个ACC_SYNCHRONIZED修饰

![image-20210714103831139](imgs\14.png)

> 两个moniterexit：一个是正常退出，一个是异常退出，保证能够退出，不会死锁

解释器执行monitorenter时会进入到`InterpreterRuntime.cpp`的`InterpreterRuntime::monitorenter`函数，具体实现如下：

```c++
IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))   #ifdef ASSERT 
thread->last_frame().interpreter_frame_verify_monitor(elem); 
#endif 
if (PrintBiasedLockingStatistics) { 
    Atomic::inc(BiasedLocking::slow_path_entry_count_addr()); 
}
Handle h_obj(thread, elem->obj()); 
assert(Universe::heap()->is_in_reserved_or_null(h_obj()), 
       "must be NULL or an object");
if (UseBiasedLocking) {  // 标识虚拟机是否开启偏向锁功能,默认开启
// Retry fast entry if bias is revoked to avoid unnecessary inflation
    ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK);  // 快速拿锁，偏向锁
} else {
    ObjectSynchronizer::slow_enter(h_obj, elem->lock(), CHECK);  // 进入slow_enter，拿自旋锁
}
assert(Universe::heap()->is_in_reserved_or_null(elem->obj()), "must be NULL or an object");
#ifdef ASSERT
thread->last_frame().interpreter_frame_verify_monitor(elem);
#endif
IRT_END
```

fast_enter

```c++
void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) { 
    if (UseBiasedLocking) {    
        if (!SafepointSynchronize::is_at_safepoint()) {      
            BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);   
            if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {        
                return;     
            }    
        } else {      
            assert(!attempt_rebias, "can not rebias toward VM thread");      
            BiasedLocking::revoke_at_safepoint(obj);    
        }    
        assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now"); 
    } //轻量级锁 slow_enter (obj, lock, THREAD);
}
```

slow_enter

```c++
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {  
    markOop mark = obj->mark();  
    assert(!mark->has_bias_pattern(), "should not see bias pattern here");  
    if (mark->is_neutral()) {  // 是否为无锁状态001    
        // Anticipate successful CAS -- the ST of the displaced mark must    
        // be visible <= the ST performed by the CAS.    
        lock->set_displaced_header(mark);    
        if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {  // CAS成功，释放栈锁     
            TEVENT (slow_enter: release stacklock) ;      
            return ;    
        }    
        // Fall through to inflate() ...  
    } else  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {    
        assert(lock != mark->locker(), "must not re-lock the same lock");    
        assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");    
        lock->set_displaced_header(NULL);    
        return;  
    }
    #if 0  // The following optimization isn't particularly useful.  
    if (mark->has_monitor() && mark->monitor()->is_entered(THREAD)) {    
        lock->set_displaced_header (NULL) ;    
        return ;  
    }
    #endif  
    // The object header will never be displaced to this lock,  
    // so it does not matter what the value is, except that it  
    // must be non-zero to avoid looking like a re-entrant lock,  
    // and must not look locked either.  
    lock->set_displaced_header(markOopDesc::unused_mark());  
    ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);  // 膨胀成重量级锁
}
```

通过ObjectSynchronizer::inflate膨胀成重量级锁

到重量级锁之后，会通过方法monitor()返回ObjectMonitor对象（c++对象，JVM层面）作为锁，提供enter、exit 获取、释放锁，运用到了底层操作系统的mutex互斥锁等机制，需要与内核交互，消耗比较大

[链接](https://www.cnblogs.com/dennyzhangdd/p/6734638.html)

> 注意：到汇编层面，无论是什么锁，都会用到lock指令
>
> - sychronized：lock cmpxchg
> - volatile：lock add，也就是内存屏障

### synchronized锁升级

> 1.2及之前的synchronized效率比较低，1.6之后得到较高提升
>
> 早期的synchronized是重量级锁，申请锁资源必须通过kernel，系统调用，底层的临界区和互斥锁等；后期优化后只需要通过用户空间内的操作，CAS等等

#### markword锁信息

> hotspot源码markOop.hpp

![image-20210714010453345](imgs\12.png)

![image-20210713205353232](imgs\10.png)

可以看到，synchronized改变了对象的对象头中的markword的锁信息。我们可以看到末位是0101，为偏向锁，这里用到的是jdk13，jdk6之后默认偏向锁，15好像又关闭了*(在存在大量锁对象的创建并高度并发的环境下禁用偏向锁能够带来一定的性能优化)*

> 可以用-XX:-UseBiasedLocking关闭偏向锁
>
> ![image-20210714094730786](imgs\13.png)
>
> 转换成无锁态和轻量锁

#### 锁升级流程

![image-20210713213130997](imgs\11.png)

> 偏向锁、轻量级锁都可以在用户空间完成
>
> 重量级锁需要向内核申请锁

- 偏向锁：线程通过CAS把自己的线程id直接贴到markword内，表示锁被自己占用了

  > 实际上，多数synchronized方法，很多情况下只有一个线程在运行，比如StringBuffer、Vector、Hashtable等都是同步方法，用时其实很多时候是单线程环境。偏向锁能够优化这些过程，实际不加锁，只是把线程id往上一贴

  > 如果一个对象调用了hashcode()方法，该对象就不可以是偏向锁了
  >
  > - 当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；
  > - 当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；
  > - 重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code
  >
  > **这里讨论的hash code都只针对identity hash code。用户自定义的hashCode()方法所返回的值跟这里讨论的不是一回事。
  > Identity hash code是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值**

- 持有偏向锁情况下，只要有其他线程参与竞争，膨胀为轻量级锁，线程通过CAS+自旋竞争锁

  锁的markword中贴上指向线程栈lock record的指针；如果是锁重入，添加一条displaced markword为空的lock record作为重入计数器，有几个就重入了几次，相应退出方法或同步块时会删除

  > 轻量级锁的加锁步骤：
  >
  > 1. 线程在自己的栈桢中创建锁记录LockRecord
  > 2. 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中，叫做displaced markword（header？这块没弄清楚，按照JVM源码BasicLock类，应当是displaced header）
  > 3. 将锁记录中的obj指针指向锁对象
  > 4. 将锁对象的对象头的MarkWord替换为指向锁记录的指针

  > PS：如果线程A持有偏向锁，线程B参与竞争，此时B会申请一个全局安全点（safe point，就是当前时间点上没有字节码正在执行）并判断A是否已结束。如果结束就进行锁撤销到无锁状态，之后再升级为轻量锁；如果没结束，则升级为轻量级锁，并恢复线程A，与B一起竞争锁，当时此时仍然是A持有锁
  >
  > [链接](https://blog.csdn.net/qq_39487033/article/details/84261640)

- 轻量级锁膨胀

  - jdk1.6之前，某线程自旋大于10次或等待的线程超过cpu核数的1/2，升级为重量级锁，可通过-XX:PreBlockSpin=\<n>调整自旋次数*(JDK7取消了)*
  - jdk1.6之后，自适应自旋，jvm自动计算自旋次数等来调整

> - 为什么要重量级锁？有轻量级不够吗
>
> 轻量级适应于单个线程任务时长较短的工作，其他线程不会自旋太久；如果任务执行很久，会造成大量自旋，消耗cpu资源并造成线程饥饿
>
> - 偏向锁效率一定比自旋锁高吗？
>
> 在明确了一定会发生线程竞争的环境下，偏向锁一定会涉及到锁撤销，建议不使用偏向锁
>
> JDK8时，JVM启动时会发生很多竞争，所以会延时4秒再开启偏向锁*(试了一下JDK13好像没有延时了)*，可以通过
>
> -XX:BiasedLockingStartupDelay=0
>
> *后面查了一下：jdk10的默认值BiasedLockingStartupDelay已更改为0。该标志BiasedLockingStartupDelay以前的默认值为4000，这将延迟锁定的使用延迟了4 s（4000 ms）。此延迟的原因是性能，但最近的性能运行显示4000 ms延迟与无延迟之间没有差异。由于存在延迟会导致VM的其他部分进行额外的工作，因此将默认值设置为0会更有意义*

<img src="imgs\23.png" alt="preview" style="zoom:200%;" />

#### 锁粗化和锁消除

- 锁粗化：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗

- 锁消除：JVM即时编译器在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁。比如说，在单线程或线程私有栈使用同步容器

  > 前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析:
  >
  > `-server `
  >
  > `-XX:+DoEscapeAnalysis`(JDK6u23之后默认开启) 
  >
  > `-XX:+EliminateLocks`
  >
  > 其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除

  > 偏向锁在执行完同步代码块,锁不会撤销成无锁的情况
  >
  > 轻量锁和重量锁在执行完同步代码块后，会执行锁撤销操作(挺耗性能毕竟要跟内核交互)，变成无锁情况

### synchronized和Lock的区别

- synchronized属于jvm层面，是java的关键字；Lock属于API层面，是一个接口
- synchronized不需手动解锁，ReentrantLock需要
- synchronized不可中断，ReentrantLock可通过tryLock设置超时中断或lockInterruptily
- synchronized是非公平的，ReentrantLock都可
- synchronized无法精确唤醒，ReentrantLock可以结合Condition实现精确唤醒

### 可重入

关于synchronized的可重入，网上很多文章写的不全面，说是靠跟锁对象关联的monitor对象的计数器来看，实际上，重量级锁时，锁对象的markword中才有指向monitor对象（_ObjectMonitor，其中有计数器字段\_recursions）的指针，但在其他几种锁中就不一样了，具体都跟lock record有密切的关系，后续会来重看。贴上我看到过的最为详细的synchronized解析：[链接](https://github.com/farmerjohngit/myblog/issues/12)，[关于lock record补充](https://baijiahao.baidu.com/s?id=1630535202760061296&wfr=spider&for=pc)

## AQS源码解读

### 前置知识：LockSupport

> 阻塞原语，park()阻塞，unpark()解除，底层是native的park和unpark方法

wait/notify局限性：①需在同步块内使用，跟ObjectMonitor绑定*（会膨胀成重量级锁，因为重量级锁才产生ObjectMonitor，对象中会有：当前持有锁的线程、WaitSet（保存处于Waiting状态的线程）、EntryList（保存处于Blocked状态的线程））*；②先阻塞，后唤醒

Lock的await/signal同上

LockSupport根据许可证（范围0-1）来控制阻塞和唤醒，每个线程都有一个permit，默认为0

park：permit - 1；unpark：permit + 1

```java
// 脱离同步块实现了阻塞
Thread a = new Thread(() -> {
    System.out.println("blocked");
    LockSupport.park();  // permit == 0，无法减，阻塞
    System.out.println("notified by b");
});
a.start();
new Thread(() -> {
    System.out.println("Im b, notify a");
    LockSupport.unpark(a);  // permit + 1，park释放锁
}).start();
```

![image-20210716014217038](imgs\29.png)

```java
// 可以先唤醒，再阻塞，不过park语句会被屏蔽掉不起作用
Thread a = new Thread(() -> {
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("current: " + System.currentTimeMillis());
    LockSupport.park();  // permit直接减1，不阻塞
    System.out.println("current: " + System.currentTimeMillis());
});
a.start();
new Thread(() -> {
    System.out.println("Im b, notify a");
    LockSupport.unpark(a);  // permit == 1
}).start();
```

![image-20210716014542201](imgs\30.png)

```java
// unpark两次，还是会阻塞，因为permit上限为1
Thread a = new Thread(() -> {
    LockSupport.park();
    System.out.println("pass first");
    LockSupport.park();
    System.out.println("pass second");
});
a.start();
new Thread(() -> {
    System.out.println("Im b, notify a");
    LockSupport.unpark(a);
    LockSupport.unpark(a);
}).start();
```

![image-20210716014959241](imgs\31.png)

### 整体概况

**AQS：抽象的队列同步器**

> 整体概念：int型的state变量+线程双向队列

<img src="imgs\33.png" alt="image-20210718183909477" style="zoom:50%;" />

> 相关类：ReentrantLock、ReentrantReadWriteLock、Semophore、CountDownLatch等

state表示锁是否被占用等状态，不被占用等于0，否则大于0；将没竞争到锁的线程封装成Node，并放入CLH队列，通过CAS+自旋来改变state的状态

### 成员变量

<img src="imgs\32.png" alt="image-20210718182728289" style="zoom:67%;" />

> state：aqs的同步状态；waitStatus：某个Node的阻塞状态

### 从ReentrantLock来解读AQS

> Lock接口的实现类，基本上都是通过`聚合`了一个`队列同步器`的子类来实现的

#### 初始化

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

![image-20210719012634908](imgs\34.png)

#### **lock**

```java
public void lock() {
    sync.acquire(1);
}
```

接着都会进入acquire方法

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

点开tryAcquire

```java
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
```

发现是个钩子方法（模板方法设计模式）

> 下面以非公平锁为例

**1. 第一个线程进入并抢占锁**

进入NonFairSync的tryAcquire

```java
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
```

进入nonfairTryAcquire方法，acquires=1

```java
@ReservedStackAccess
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

发现调用的是父类Sync的nonfairTryAcquire方法，首先c == state 一定为0，因为是首次，默认值为0

接着通过CAS改变AQS的同步状态，表面锁已被占用，调用setExclusiveOwnerThread方法

```java
protected final void setExclusiveOwnerThread(Thread thread) {
    exclusiveOwnerThread = thread;
}
```

调用的是AQS的父类AbstractOwnableSychronizer的方法，独占锁的线程令为当前线程

再回到nonfairTryAcquire方法，return true，在acquire方法中直接跳出if语句，不做任何处理，线程独占锁成功

总结起来：

![image-20210719024132787](imgs\35.png)

**2. 第二个及后续线程进入并抢占锁**

回到nonfairTryAcquire方法

```java
@ReservedStackAccess
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

c != 0，说明有线程占有锁，这里有两种情况：

1. 当前想要竞争锁的线程就是已经占有锁的线程

令nextc = c + 1，并相应修改state的值，这里state就相当于是记录lock()的次数

同样return true，跳出acquire的if循环，结束方法

体现**可重入性**

总结起来：

![image-20210719024048443](imgs\36.png)

2. 另一个线程来竞争锁，return false，进入if循环，执行 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法

- addWaiter方法

首先是addWaiter(Node.EXCLUSIVE)，线程以排他/独占的模式等待锁，带参初始化，将当前线程封装成Node

```java
Node(Node nextWaiter) {
    this.nextWaiter = nextWaiter;
    THREAD.set(this, Thread.currentThread());
}
```

```java
private Node addWaiter(Node mode) {
    Node node = new Node(mode);

    for (;;) {
        Node oldTail = tail;
        if (oldTail != null) {
            node.setPrevRelaxed(oldTail);
            if (compareAndSetTail(oldTail, node)) {
                oldTail.next = node;
                return node;
            }
        } else {
            initializeSyncQueue();
        }
    }
}
```

这里有两种情况：

1. 第一种情况，进入的为第二个线程

进入AQS的initializeSyncQueue方法

```java
private final void initializeSyncQueue() {
    Node h;
    if (HEAD.compareAndSet(this, null, (h = new Node())))
        tail = h;
}
```

新建一个Node节点，this指AQS，令当前AQS的head从null变成new Node，并也令tail == new Node

**！！！注意：这里的new Node是空节点，只是作为占位符，也就是说，head是虚头，又称哨兵节点，thread == null， waitStatus == 0**

接着重新回到addWaiter的循环中，进行if中的逻辑

> 我在这里想到这里有一个“先检查再修改”的竞态条件，会线程不安全吗
>
> 后来想了一下，会有这种情况，A线程进入if，tail还没设置好的时候，B线程令Node oldTail = tail，指向了没修改之前的tail，也就是null，此时B线程也进入initializeSyncQueue()，但就无法进入if逻辑了，接着返回for循环，Doug Lea，yyds！

2. 进入的为第n个线程（n > 2）

直接不断循环这段逻辑

```java
Node oldTail = tail;
if (oldTail != null) {
    node.setPrevRelaxed(oldTail);  // 令node的prev指向tail
    // 令tail = node，node变成新队尾，oldTail的next指向node
    // 也就是把node添加到队尾
    if (compareAndSetTail(oldTail, node)) {
        oldTail.next = node;
        return node;
    }
}
```

> 我在这里也想到这里有一个“先检查再修改”的竞态条件，会线程不安全吗
>
> 后来想了一下，就算两个node的oldTail相同，也只有一个能成功CAS添加进队列，另一个只能重新循环，刷新oldTail，逻辑是非常严密的

最后，将当前节点返回

总结起来：

![image-20210719032659250](imgs\37.png)

- acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法

我们知道了，addWaiter返回的是当前线程封装成的node

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean interrupted = false;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node))
                interrupted |= parkAndCheckInterrupt();
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        if (interrupted)
            selfInterrupt();
        throw t;
    }
}
```

线程首先进入循环

```java
final Node predecessor() {
    Node p = prev;
    if (p == null)
        throw new NullPointerException();
    else
        return p;
}
```

首先令p为当前节点的prev节点

1. 如果prev是head，首先尝试拿锁

   - 没拿到

     进入第二个if，调用shouldParkAfterFailedAcquire(p, node)判断，注意，此时头节点的waitStatus为0，因此，将头节点的waitStatus设置为-1

     ```java
     private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
         int ws = pred.waitStatus;
         if (ws == Node.SIGNAL)
             /*
              * This node has already set status asking a release
              * to signal it, so it can safely park.
              */
             return true;
         if (ws > 0) {
             /*
              * Predecessor was cancelled. Skip over predecessors and
              * indicate retry.
              */
             do {
                 node.prev = pred = pred.prev;
             } while (pred.waitStatus > 0);
             pred.next = node;
         } else {
             /*
              * waitStatus must be 0 or PROPAGATE.  Indicate that we
              * need a signal, but don't park yet.  Caller will need to
              * retry to make sure it cannot acquire before parking.
              */
             pred.compareAndSetWaitStatus(ws, Node.SIGNAL);
         }
         return false;
     }
     ```

     return false

     > 如果ws>0，只可能是CANCELLED，则直接从队列中移除，并不断判断前面的节点是否CANCELLED
     > 这里需要知道，唤醒的操作是由前驱节点完成的
     > 所以while循环说的是将当前节点的prev指向waitStatus<=0的节点，跳过那些ws>0的节点
     > 得找到一个有能力将当前节点唤醒的前驱节点，才能“放心”地park
     >
     > 注意看else的注释里面，Caller will need to retry to make sure it cannot acquire before parking，会进行两次tryAcquire，第一次是令prev的ws = -1，第二次是“make sure it cannot acquire before parking”，确保挂起之前，确实拿不到锁了

     接着再进入循环，如果还是没有拿到锁，则再次进入shouldParkAfterFailedAcquire(p, node)方法，此时head的ws已经是-1了，所以return true，表示可以挂起等待

     ```java
     private final boolean parkAndCheckInterrupt() {
         LockSupport.park(this);
         // 注意！！！这里一定要用interrupted()而不是isInterrupted()
         // 要清除标志位，否则park会一直检测中断标志位为true，就一直不会阻塞了！（park方法遇到中断标志位为true时不阻塞）
         return Thread.interrupted();
     }
     ```

     使用LockSupport.park来挂起当前线程

     **注意！！！**：LockSupport处理中断的方式和wait、sleep等不同，它不会抛出异常，而是直接结束阻塞状态，执行下面的语句。所以，如果一直没拿到锁，会是这样的走向

     ![image-20210719213648759](imgs\40.png)

     > **为什么不一直head后第一个node不一直自旋直到获取锁？**因为太消耗cpu资源了

   - 拿到了

     进入第一个if，首先setHead，令当前node成为哨兵节点；并令旧head的next指向null，方便gc

     ```java
     private void setHead(Node node) {
         head = node;
         node.thread = null;
         node.prev = null;
     }
     ```

2. 如果prev不是head

   进入shouldParkAfterFailedAcquire，将prev的ws置为-1，并将自身挂起，直到前置节点将其唤醒或发生中断

对于中断处理，如果在获取锁的过程中发生中断，则临时变量interrupted置为true，然后调用selfInterrupt令线程的中断标志位为true；抛出异常的时候会调用cancelAcquire(node)

> 为什么要设置interrupted这么一个临时变量，而不是直接在判断的时候就Thread.currentThread().interrupt()
>
> 因为，线程在等待过程中，是无法调用方法，无法接受外部中断信息的，只有在拿到锁能够执行之后，才能够响应外部中断，并在lock()方法下面的代码中对中断进行处理*（当然也可以不处理啦）*

```java
private void cancelAcquire(Node node) {
    // Ignore if node doesn't exist
    if (node == null)
        return;

    node.thread = null;

    // Skip cancelled predecessors
    Node pred = node.prev;
    while (pred.waitStatus > 0)
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary, although with
    // a possibility that a cancelled node may transiently remain
    // reachable.
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    if (node == tail && compareAndSetTail(node, pred)) {
        pred.compareAndSetNext(predNext, null);
    } else {
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &&
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws <= 0 && pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &&
            pred.thread != null) {
            Node next = node.next;
            if (next != null && next.waitStatus <= 0)
                pred.compareAndSetNext(predNext, next);
        } else {
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
```

总结起来

![image-20210719154827130](imgs\38.png)

![image-20210719155904620](imgs\39.png)

在shouldParkAfterFailedAcquire和cancelAcquire中都会循环去除ws > 0的节点

***TODO*：cancelAcquire中的else逻辑没太看懂...也不懂为啥要unpark，后面再看吧...看累了-_-**

总结起来个大概吧：①tryAcquire获取锁；②没获取到进入阻塞队列；③head可以unpark队头，之后自旋在acquireQueued中调用tryAcquire用CAS竞争锁（改变state）

#### unlock

```java
public void unlock() {
    sync.release(1);
}
```

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

进入aqs.sync的release方法，tryRelease，同样是钩子方法，模板方法设计模式

> 不再是NonFairSync的方法了，而是父类Sync里面的方法

```java
@ReservedStackAccess
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

可以看作，如果state == 0，释放成功，return true

```java
if (tryRelease(arg)) {
    Node h = head;
    if (h != null && h.waitStatus != 0)
        unparkSuccessor(h);
    return true;
}
```

如果为true的话，此时h == new Node()，h.ws == -1，调用unparkSuccessor方法

```java
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws < 0)
        node.compareAndSetWaitStatus(ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node p = tail; p != node && p != null; p = p.prev)
            if (p.waitStatus <= 0)
                s = p;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

首先将head的waitStatus设为0，但这一步是允许失败的，接着看next节点，如果next为null或者ws>0，从后往前找head之后第一个ws <= 0的节点，并将它唤醒

> 为什么要从后往前找
>
> 看注释
>
> Thread to unpark is held in successor, which is normally just the next node.  But if cancelled or apparently null, traverse backwards from tail to find the actual non-cancelled successor.
>
> 从前往后找，有可能有个线程取消了，或者什么其他情况，导致next就为null，就找不到下一个节点了，而从后往前，才能找到“actual non-cancelled successor”
>
> 比如说，有可能有这样一种情况：
>
> ![image-20210719230627156](imgs\43.png)
>
> 线程A抢先拿到锁并执行，B入队；恰巧在B第二次retry tryAcquire之前，A执行完毕，释放锁，令state = 0，h = head，指向head节点；在A setState并令h = head之后，B第二次retry tryAcquire可通过CAS拿到锁，此时再调用setHead方法，令原head作废了；接着A再令s = h.next，也就是等于原head的next，就为null，无法唤醒下一个节点了
>
> ***TODO*：取消可能会出现的情况没考虑了，后面再看吧...看累了-_-**

tryRelease之后，**①state == 0；②线程unpark；③线程node调用acquireQueued方法进入循环并通过CAS竞争锁，node变成新的哨兵节点**

**公平锁**

```java
protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}
```

注意到，多了一个hasQueuedPredecessors()的判断

```java
public final boolean hasQueuedPredecessors() {
    Node h, s;
    if ((h = head) != null) {
        if ((s = h.next) == null || s.waitStatus > 0) {
            s = null; // traverse in case of concurrent cancellation
            for (Node p = tail; p != h && p != null; p = p.prev) {
                if (p.waitStatus <= 0)
                    s = p;
            }
        }
        if (s != null && s.thread != Thread.currentThread())
            return true;
    }
    return false;
}
```

判断队首，也就是head的next是否存在，存在的话直接返回true，进入acquireQueued(addWaiter(Node.EXCLUSIVE), args)那一套逻辑。意思就是：队列中如果有已经在等待的线程，那么新来的线程自动去排队，不能直接参与CAS竞争锁

> 值得注意的是：公平锁也可以调用非公平的tryLock方法，因为nonfairTryAcquire是Sync当中的方法
>
> ```java
> public boolean tryLock() {
>     return sync.nonfairTryAcquire(1);
> }
> ```



## 参考

[1] [尚硅谷Java大厂面试题全集——周阳](https://www.bilibili.com/video/BV1zb411M7NQ?from=search&seid=14945934539833643051&spm_id_from=333.788.b_636f6d6d656e74.212)

[2] [https://www.jianshu.com/p/ef8de88b1343——激情的狼王](https://www.jianshu.com/p/ef8de88b1343)

[3] [https://blog.csdn.net/hqq2023623/article/details/51013468——Oo此岸花开oO](https://blog.csdn.net/hqq2023623/article/details/51013468)

[4] [https://blog.csdn.net/qq_29066533/article/details/109681801——S-U-M-M-E-R](https://blog.csdn.net/qq_29066533/article/details/109681801)

[5] [https://blog.csdn.net/qq_39487033/article/details/84261640——程序瑶](https://blog.csdn.net/qq_39487033/article/details/84261640)

[6] [https://github.com/farmerjohngit/myblog/issues/12——farmerjohngit](https://github.com/farmerjohngit/myblog/issues/12)

[7] [https://baijiahao.baidu.com/s?id=1630535202760061296&wfr=spider&for=pc——IT一刻钟](https://baijiahao.baidu.com/s?id=1630535202760061296&wfr=spider&for=pc)

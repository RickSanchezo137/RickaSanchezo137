# [返回](/)

# 八股文背诵版之—Java基础篇

## final

### :point_right:**讲一下final？**

final是Java的关键字，可以用来修饰类、方法和变量，被final修饰的类是不可以被继承的，被final修饰的方法不可以被重写，被final修饰的变量的值不可以改变。除此之外，final还具有两个语义：第一个是，创建对象时，初始化写final域，与将对象地址赋给一个引用变量，这两个操作之间不能重排序；第二个是，初次读包含final域的对象引用，与读取这个final域，这两个操作之间不能重排序

实现第一个规则是在final域写之后，构造方法结束前插入一个StoreStore屏障，令写入final域对其他cpu可见，且阻止了重排序；第二个规则是在读final域之前插入一个LoadLoad屏障，阻止了在读取对象引用前读取final域的重排序

x86架构下，LoadLoad和StoreStore都是空操作，用到这两种内存屏障的场景中，x86架构下处理器不会进行重排序，因此实际并没有给final插入内存屏障

> JIT和处理器都可能进行重排序；内存屏障的具体实现是在**硬件层面的指令**，一般有lock、mfence、cpuid等

### :point_right:**final、finally、finalize的区别？**

final是Java的关键字，用来修饰类时，类不能被继承；用来修饰方法时，方法不能被重写；用来修饰变量时，变量的值不能被修改。finally也是Java的关键字，用在异常捕获处理中，在try-catch-finally中，被finally包住的代码块一定会被执行，可以用来做一些资源清理的工作；在return后的finally会先执行完再return，finally中的return会覆盖前面的return。finalize是Java中的方法，在GC过程中会被低优先级的Finalizer线程调用，作为GC流程的一部分

### :point_right:**为什么方法内部类使用方法的变量时，这个变量一定要是final的？**

两者生命周期不一致，内部类在方法结束后对应栈帧出栈后依然存在，而局部变量在方法结束后就会销毁，如果在内部类使用一个已经销毁的变量，肯定是不可以的，因此将变量令为final的，编译时会传入内部类作为内部类的一个成员变量而存在

## String

### :point_right:**String为什么不可变？**

首先，String是被final修饰的，是不能被继承的，因此不能通过继承它来重写覆盖它的方法；其次，String底层的byte数组是用final修饰的，不能指向其他数组；最后是最关键的，String中对底层数组采用private修饰，封装并提供给用户的涉及到修改的方法都会仔细避免修改底层数组，而是返回一个新的String对象，因此说String是不可变的

## 包装类

### :point_right:**为什么使用包装类？**

因为Java语言是面向对象的语言，而Java基本数据类型不是面向对象的，因此就不具备面向对象的一些特性，不能使用方法，也不能在容器内使用，因此对其进行包装，赋予其面向对象特性

### :point_right:**Integer a = 128、Integer b = 128，a == b是否为true？为什么？**

不为true，Integer a = 128是一个语法糖，实际上会被编译成Integer.valueOf(128)，这个方法在参数处于-128到127的时候会返回Integer.cache数组对应索引位置的值，这是一个静态数组，随着类的加载而加载，并在静态代码块中完成了赋值，因此在-128到127间的数都是从这个数组取，都相等；而在这个范围之外的数，使用new创建了一个对应的Integer对象并返回，因此==比较的是地址，而两个不同对象在堆上的地址肯定是不同的，所以为false

## 泛型

## 反射

## 异常

### :point_right:**Error和Exception的区别？**

Error通常是虚拟机运行过程中出现的相关错误，比如系统崩溃、堆栈溢出等等，编译器不对这类错误进行检查，Java应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止；Exception类型可以被捕获并处理，应用程序可以继续正常运行

### :point_right:**受检异常和非受检异常的区别？**

非受检异常又称运行时异常，为RuntimeException及其子类，两者区别如下：

- 受检异常会在编译期间进行检查，非受检异常不会
- 受检异常会强制要求处理，非受检异常不要求强制处理

## 新特性



## 大厂真题






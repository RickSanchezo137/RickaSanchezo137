# [返回](/)

# 八股文背诵版之—Java基础篇

## 基础

### :point_right:**讲一下final？**

final是Java的关键字，可以用来修饰类、方法和变量，被final修饰的类是不可以被继承的，被final修饰的方法不可以被重写，被final修饰的变量的值不可以改变。除此之外，final还具有两个语义：第一个是，创建对象时，初始化写final域，与将对象地址赋给一个引用变量，这两个操作之间不能重排序；第二个是，初次读包含final域的对象引用，与读取这个final域，这两个操作之间不能重排序

实现第一个规则是在final域写之后，构造方法结束前插入一个StoreStore屏障，令写入final域对其他cpu可见，且阻止了重排序；第二个规则是在读final域之前插入一个LoadLoad屏障，阻止了在读取对象引用前读取final域的重排序

x86架构下，LoadLoad和StoreStore都是空操作，用到这两种内存屏障的场景中，x86架构下处理器不会进行重排序，因此实际并没有给final插入内存屏障

> JIT和处理器都可能进行重排序；内存屏障的具体实现是在**硬件层面的指令**，一般有lock、mfence、cpuid等

### :point_right:**String为什么不可变？**

首先，String是被final修饰的，是不能被继承的，因此不能通过继承它来重写覆盖它的方法；其次，String底层的byte数组是用final修饰的，不能指向其他数组；最后是最关键的，String中对底层数组采用private修饰，封装并提供给用户的涉及到修改的方法都会仔细避免修改底层数组，而是返回一个新的String对象，因此说String是不可变的

### :point_right:**final、finally、finalize的区别？**

final是Java的关键字，用来修饰类时，类不能被继承；用来修饰方法时，方法不能被重写；用来修饰变量时，变量的值不能被修改。finally也是Java的关键字，用在异常捕获处理中，在try-catch-finally中，被finally包住的代码块一定会被执行，可以用来做一些资源清理的工作；在return后的finally会先执行完再return，finally中的return会覆盖前面的return。finalize是Java中的方法，在GC过程中会被低优先级的Finalizer线程调用，作为GC流程的一部分

## 异常

### :point_right:**Error和Exception的区别？**

Error通常是虚拟机运行过程中出现的相关错误，比如系统崩溃、堆栈溢出等等，编译器不对这类错误进行检查，Java应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止；Exception类型可以被捕获并处理，应用程序可以继续正常运行

### :point_right:**受检异常和非受检异常的区别？**

非受检异常又称运行时异常，为RuntimeException及其子类，两者区别如下：

- 受检异常会在编译期间进行检查，非受检异常不会
- 受检异常会强制要求处理，非受检异常不要求强制处理

## 大厂真题






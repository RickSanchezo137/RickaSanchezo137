# [返回](/)

# 八股文背诵版之—应用篇

## 故障分析&线上排查

### :point_right:**cpu使用率飙升排查？**

window利用任务管理器查看，主要是Linux：

1. 终端运行top指令，shift+p按cpu占用率从上到下排序，找到对应的pid
2. 使用top -H -p pid进入线程模式，会显示对应进程下的所有线程，终端对应的pid字段为线程号
3. 线程号转换成16进制，记为nid
4. 使用jstack pid > /tmp/info.dat输出所有堆栈信息
5. 打开该文件info.dat，查找nid对应部分的信息

## 系统设计



## 个人项目

### :point_right:**简单介绍一下项目？在项目中的工作？**

1. 首先是网络理政中心项目，项目的来源是成都市高新区网络理政中心。主要的任务场景是这样的，高新区理政中心现场有三个由若干个小屏构成的大屏，每个小屏后面装有温度传感器，除此之外，还有一些机房安装了烟雾传感器温度传感器等等，我们要做的是根据传感器收集到的数据来判断大屏或机房有没有出现温度过高或其他一些可能导致安全隐患的情况，并通过可视化技术展示出来。大概流程是这样的：传感器采集数据之后发送给mqtt broker，mqtt broker的订阅端接收数据并发送到mongodb数据库，我们的可视化平台从数据库中查询数据，并发送到前端展示

   我在项目中的主要职责是可视化平台后端的开发，其中我主要负责传感器历史数据的查询、大屏实时温度的查询、出入参日志的打印及用户操作记录

   - 传感器的历史查询主要采用redis作为缓存、mongodb作为持久化数据库来实现的。在mongodb中按大屏分为若干个document，放在history的collection里面；redis使用zset来存储历史数据，格式是history:screenId:timeUnit:设备ID，然后value为设备对象的序列化，score为它的时间戳，不同timeUnit对应的历史数据采样频率不一致。整体流程是这样的：前端发送查询历史数据的请求，缓存和mongodb以责任链的模式来处理请求，首先在Service层构造一个责任链，通过将handler对象传入列表，并循环列表setNextHandler，最后返回firstHandler，调用getHistory方法*（好处是降低代码耦合性，更加优雅的实现，避免if-else这种硬编码）*，并返回一个List来存储历史数据，第一个handler为BufferHistoryHandler，从缓存中取，如果取的不够或没取到，则调用下一个handler DBHistoryHandler从数据库中取，并将结果返回给这个handler，推送到redis中去，同时删除redis中过老的数据，除此之外还定时删老数据，相当于是定时策略和惰性策略的结合，再返回给前端。推送到redis的过程中会进行重采样，小于1h的放入hour键，超过1h的重采样并放入day键，超过1day的重采样并放入month键，返回给前端用的是遍历list+pipeline，不过pipeline可能会具有原子性问题
   - 大屏实时温度的查询，前端传入大屏设备ID参数，首先想的思路是直接从数据库中拿，也就是以设备ID、存入时间戳的降序、温度，构建联合索引，取第一条返回，加快查询速度。查询采用线程池开启多个线程同时查，每个线程负责不同的设备ID范围，先用的是一个ArrayList，结果前端显示有几块屏数据数据丢失，意识到出现并发安全问题，采用CopyOnWriteArrayList，意识到查询操作会往容器进行很多次写操作，进行了很多次底层数组的拷贝，可能会触发频繁gc，而且synchronized方法影响了并发性能，最后改成每个线程往自己对应的ArrayList中存，最后再合并返回
   - 出入参日志的打印及用户操作记录，主要采用了AOP和ThreadLocal。AOP采用了注解作为切点，在每个方法添加注解，切面类中定义一个全局的ThreadLocal\<StringBuilder>对象，每个请求线程相互隔离的往StringBuilder对象中添加日志，最后统一打印出来，实现日志打印的隔离有序；用户操作记录结合了过滤器和ThreadLocal，在过滤器的doFilterInternal中首先验证token*（放入redis实现过期）*，接着根据token中解析出email信息并在数据库中查询到user信息，将user对象用全局的ThreadLocal封装，接下来进入切面类定义的方法，根据JointPoint对象、Request对象以及User对象将方法名、IP地址、用户信息等等都存放到数据库中，实现用户操作的记录，不过想到可能会面对线程复用的问题*（Tomcat线程池）*

2. 然后是四川大学插排项目，主要是从华为智能插排获取用电数据监测安全情况，并通过华为云平台下发指令控制插排

   我的主要工作是后端的开发，负责的功能点有历史数据的查询、Redis限流、SSE推送、出入参日志的打印及用户操作记录。历史数据的查询代码和上面有一定程度的复用，在责任链的中间加入了一个IotPlatformHistoryHandler，然后采取策略模式和不同的第三方平台对接并取历史数据，有华为、曼顿空开以及tuya等等，策略模式的使用是根据传过来的设备ID参数查询设备IoT平台的信息，并返回包含不同IoT平台serviceImpl对象，并调用相应的getHistory方法*（封装具体实例也封装具体方法）*。SSE推送是如果定时任务发现有电压或其他值超过阈值，就向客户端主动发送一个消息，需要维持一个长连接，是单工通信。Redis限流是调用zset实现的

### :point_right:**技术选型怎么做的？为什么不用微服务架构？**

考虑到

### :point_right:**项目难点有哪些？**

1. Redis限流

   

### :point_right:**有没有线上排查经历？**



### :point_right:**为什么要用mongodb？**



### :point_right:**有没有线上排查经历？**
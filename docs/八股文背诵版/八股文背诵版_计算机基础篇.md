# [返回](/)

# 八股文背诵版之—计算机基础篇

## 数据结构

红黑树、跳表



## 操作系统



## 计算机网络

### :point_right:讲讲网络分层结构？

- 应用层，负责应用程序之间的数据交互，典型的协议有HTTP、SMTP
- 传输层，负责主机进程之间的通信，典型的协议有TCP、UDP
- 网络层，根据路由表，负责网络数据正确的路由转发
- 链路层，根据链路层协议，将网络层下发的数据包封装成数据帧，实现两个相邻节点之间的传输
- 物理层，通过物理的介质保证数据的传输，并向上层屏蔽物理层设备的差异

### :point_right:三次握手？

1. 首先客户端服务端都处于closed状态，服务端进入listen状态
2. 客户端发送SYN=1，seq=x，进入SYNC_SEND状态
3. 服务端监听到报文，向客户端发送SYN=1，ACK=1，seq=y，ack=x+1，进入SYNC_RECV状态
4. 客户端接收到报文，返回ACK=1，seq=x+1，ack=y+1，进入established状态
5. 服务端接收到报文，准备好连接的服务资源，建立连接，进入established状态

### :point_right:为什么不能两次握手？

为了防止重传的已失效的客户端的报文段对服务端产生影响

比如客户端一开始的报文由于网络等原因没传到，又重新建立一个新连接并完成数据传输并释放，结果一开始的本应失效的报文又传到服务端了，服务端返回ACK，如果此时服务端就认为建立连接了，是永远接收不到客户端的响应的，白白浪费资源

### :point_right:四次挥手？

1. 首先客户端和服务端都处于established状态
2. 接着客户端发送FIN=1，seq=x，进入FIN_WAIT1状态
3. 服务端接收到客户端的报文，返回ACK=1，seq=y1，ack=x+1，表示收到了报文，准备关闭连接之前的操作了，进入CLOSE_WAIT状态
4. CLOSE_WAIT状态后，服务端返回FIN=1，ACK=1，seq=y2，ack=x+1，表示已经完成关闭连接之前的操作了，进入LAST_ACK状态
5. 客户端接收到报文，返回ACK=1，seq=x+1，ack=y2+1，等待2MSL（Maximum Segment Lifetime），进入closed状态
6. 服务端接收到last ack，进入closed状态

### :point_right:为什么要等待2MSL？

1. 为了防止服务端没有接收到last ack，迟迟不能关闭。服务端没有接受到last ack，会在2MSL内重传FIN报文，客户端收到后也会重传last ack，并再次等待2MSL，保证服务端连接正常关闭
2. 超过最大报文生存时间，本次连接的报文段全部消失，不会影响下一次的连接

### :point_right:为什么要四次挥手？

比如握手的时候，可以直接返回SYN和ACK，但挥手时不行，服务端可能还存在有没有传输完成的报文，因此需要完全传完之后，再返回FIN+ACK，表示真正可以关闭连接了

### :point_right:TCP特点？和UDP的区别？

TCP特点：

- 是面向连接的
- 可靠交付的
- 点对点的
- 全双工的
- 字节流形式的

和UDP区别：

- UDP不面向连接
- UDP不提供可靠交付
- UDP可一对一、一对多、多对一、多对多
- UDP面向报文
- UDP首部为8字节，TCP为20字节
- UDP不支持拥塞控制

### :point_right:TCP拆包、粘包？如何解决？

TCP拆包：

- 要发送的数据大于发送端缓冲区的大小
- 发送的数据包大小大于MSS*（Maaximum Segment Size）*，会进行拆包

TCP粘包：

- 接收端的应用没有及时接收缓冲区的数据
- 发送的数据包小于发送缓冲区的大小，多个数据包一起发送了

解决：*（都是上层应用层面提供的）*

- 发送端将数据包封装成固定大小，避免小于或大于缓冲区，累计读取到长度和为定长LEN的报文后，就认为读取到了一个完整的信息
- 应用端制定通信协议，用特殊的字段标识，后面根据字段进行数据包的重组
- 通过在消息头中定义长度字段来标识消息的总长度

### :point_right:TCP拥塞控制？

拥塞控制有这样几种算法：慢开始、拥塞避免、快重传、快恢复

- 慢开始：TCP发送报文的时候，一开始因为不知道网络的拥塞状况，所以采用逐步增加的策略。所以一开始拥塞窗口cwnd大小初始化为1，然后逐步增加，每一个RTT后乘2
- 拥塞避免：达到慢门限阈值ssthresh=16后，每一个RTT后加1，如果某次发生了拥塞，则ssthresh设置为当前的一半，重新慢开始
- 快重传：传统方式下，接收方收到失序报文，不作处理，发送端等到重传超时之后进行重传，不过这样会影响效率。在快重传算法下，接收方会重复发送丢失序号的报文的ACK，发送端接连收到三个这样的ACK时，可以认定报文丢失，立即进行重传
- 快恢复：在接收端连续收到三次重复ACK，进入快恢复，cwnd大小变为一半，并每一个RTT后加1

### :point_right:讲讲HTTP协议？报文格式？

HTTP协议是运行在网络层之上的协议，它是一种无状态的协议，可以传输Content-Type指定类型的任意数据。请求报文格式为请求行、请求头、空行、请求体；响应报文格式为状态行、响应头、空行、响应体

### :point_right:HTTP状态码？

- 1xx：服务端接收到客户端请求，客户端进行进一步处理*（对客户端不可见）*
  - 
- 2xx：
- 3xx：
- 4xx：
- 5xx：

### :point_right:HTTP1.0和1.1区别？

HTTP 1.0是默认短连接的，可以修改请求头为Connection:keep-alive，HTTP 1.1是默认长连接的，客户端可以复用这个连接，不过前一个请求阻塞了，可能导致后面的也阻塞，出现队头阻塞问题

HTTP 1.0不支持断点续传，HTTP 1.1支持断点续传

HTTP 1.1比1.0多了24种错误状态码

HTTP 1.1比HTTP 1.0请求头多了Host信息，用于支持虚拟机等等

### :point_right:HTTP1.1和2.0区别？

HTTP 2.0是二进制传输的，1.1是文本格式的

HTTP 2.0是基于多路复用并行传输的，不会出现1.1版本中那种队头阻塞的问题

HTTP 2.0是支持服务端主动推送的，1.1不支持

HTTP 2.0是可以头部帧、数据帧，支持头部压缩；对于重复数据可以支持不重复传

### :point_right:HTTP和HTTPS区别？

HTTP是无加密传输的，未验证身份，容易被冒充或中间人篡改，HTTPS是加密传输的，运行在ssl之上，需要向CA机构申请证书

HTTP是80端口，HTTPS是443端口

### :point_right:什么是数字证书？



### :point_right:HTTPS原理？



### :point_right:DNS的解析过程？



### :point_right:浏览器输入URL的返回过程？



### :point_right:Cookie和Session的区别？



### :point_right:什么是对称加密和非对称加密？
# [返回](/)

# 八股文背诵版之—计算机基础篇

## 数据结构

红黑树、跳表



## 操作系统

### :point_right:**进程、线程的区别？**

- 进程是系统资源分配的基本单位、线程是cpu调度和任务执行的基本单位，一个进程可以包含有多个线程
- 每一个进程有自己独立的代码和数据空间，切换时开销较大，而同一进程下的多个线程共享进程的地址空间和资源，有自己独立的PC计数器和运行栈，切换开销较小
- 多个进程之间互不影响；而一个线程挂掉会导致所在的整个进程崩溃

### :point_right:**为什么进程切换开销比线程大？**

进程切换涉及到进程cpu环境的切换，包括栈和寄存器的切换、虚拟地址的切换、页表的切换；线程切换涉及到栈和寄存器的切换，不涉及虚拟地址的切换。在进程运行的过程中，MMU的控制下，有虚拟地址到物理地址的映射，这一功能是靠页表来实现的，页表的查找是一个开销比较大的操作，因此诞生出TLB*（Translation Lookaside Buffer）*，俗称快表，将页表的一部分缓存到高速缓冲区，减少对主存的访问次数，加快访问速度，而进程的切换会切换页表，快表也失效，因此导致开销比较大，线程的切换不会切换页表，快表也不失效，所以开销小

### :point_right:**进程之间通信方式？**

- 管道：无格式字节流、大小受限
  - 匿名管道：父子进程之间，调用pipe函数，实现半双工通信，本质上是一个内存中的内核缓冲区
  - 有名管道：任意两进程之间，调用mkfifo函数，实现半双工通信，能以文件形式存在
- 信号：比如用户注销，给进程发送SIGUP信号；杀死进程，发送SIGKILL信号，对应kill -9 pid指令；SIGCHILD
- 信号量：进程之间同步访问共享资源的手段，可看作一个计数器
- socket：两进程之间通信，比如TCP
- 共享内存：若干进程虚拟地址直接映射到同一物理地址，如多个进程通过mmap操作文件
- 消息队列：克服了管道无格式、容量小、会阻塞的缺点

### :point_right:**进程/线程之间通信方式？**

进程之间：信号量、互斥量（可命名）

线程之间：事件（wait/notify）、临界区（不可命名）、互斥量、信号量

### :point_right:**进程调度策略？**

- 先来先服务调度：FCFS，先来的先获得cpu
- 短作业优先调度：同时到来的，先选择短作业
- 优先级调度：同时到来的，先选择优先级高的
- 多级反馈队列调度：队列按顺序排，按顺序依次执行各个队列的作业，不同优先级的作业进入不同的队列，一个时间片执行完后进入下一个队列，前面的队列时间片较短，后面的较长
- 时间片轮转调度：固定时间片

### :point_right:**分页和分段的区别？**

分页：

分段：

区别：

### :point_right:**页面置换算法？**

FIFO先进先出、LRU最近最久未访问、LFU最近最少频次访问、......

### :point_right:**什么是僵尸进程？什么是孤儿进程？**

僵尸进程就是子进程运行结束，但父进程没有运行结束，同时父进程没有对子进程进行妥善的处理和回收，产生僵尸进程。这些僵尸进程将保留进程ID、运行时间、退出状态等信息，导致系统进程ID用完，无法产生新进程。解决方法是：父进程调用wait等待子进程结束，子进程结束会发送SIGCHILD信号，父进程接收信号，处理子进程的回收；或者结束父进程，让子进程变成孤儿进程，由系统提供的init进程回收

> 每个进程结束，系统会扫描它是否有子进程，如果有，令init进程接管，成为它的父进程

孤儿进程就是父进程结束，子进程未结束，一般由init进程接管，不会造成危害

## 计算机网络

### :point_right:讲讲网络分层结构？

- 应用层，负责应用程序之间的数据交互，典型的协议有HTTP、SMTP
- 传输层，负责主机进程之间的通信，典型的协议有TCP、UDP
- 网络层，根据路由表，负责网络数据正确的路由转发
- 链路层，根据链路层协议，将网络层下发的数据包封装成数据帧，实现两个相邻节点之间的传输
- 物理层，通过物理的介质保证数据的传输，并向上层屏蔽物理层设备的差异

### :point_right:三次握手？

1. 首先客户端服务端都处于closed状态，服务端进入listen状态
2. 客户端发送SYN=1，seq=x，进入SYNC_SEND状态
3. 服务端监听到报文，向客户端发送SYN=1，ACK=1，seq=y，ack=x+1，进入SYNC_RECV状态
4. 客户端接收到报文，返回ACK=1，seq=x+1，ack=y+1，进入established状态
5. 服务端接收到报文，准备好连接的服务资源，建立连接，进入established状态

### :point_right:为什么不能两次握手？

**为了防止重传的已失效的客户端的报文段对服务端产生影响**

比如客户端一开始的报文由于网络等原因没传到，又重新建立一个新连接并完成数据传输并释放，结果一开始的本应失效的报文又传到服务端了，服务端返回ACK，如果此时服务端就认为建立连接了，是永远接收不到客户端的响应的，白白浪费资源

### :point_right:四次挥手？

1. 首先客户端和服务端都处于established状态
2. 接着客户端发送FIN=1，seq=x，进入FIN_WAIT1状态
3. 服务端接收到客户端的报文，返回ACK=1，seq=y1，ack=x+1，表示收到了报文，准备关闭连接之前的操作了，进入CLOSE_WAIT状态
4. CLOSE_WAIT状态后，服务端返回FIN=1，ACK=1，seq=y2，ack=x+1，表示已经完成关闭连接之前的操作了，进入LAST_ACK状态
5. 客户端接收到报文，返回ACK=1，seq=x+1，ack=y2+1，等待2MSL（Maximum Segment Lifetime），进入closed状态
6. 服务端接收到 last ack，进入closed状态

### :point_right:为什么要等待2MSL？

1. 为了防止服务端没有接收到last ack，迟迟不能关闭。服务端没有接受到last ack，会在2MSL内重传FIN报文，客户端收到后也会重传last ack，并再次等待2MSL，保证服务端连接正常关闭
2. 超过最大报文生存时间，本次连接的报文段全部消失，不会影响下一次的连接

### :point_right:为什么要四次挥手？

比如握手的时候，可以直接返回SYN和ACK，但挥手时不行，服务端可能还存在有没有传输完成的报文，因此需要完全传完之后，再返回FIN+ACK，表示真正可以关闭连接了

### :point_right:TCP特点？和UDP的区别？应用场景？

TCP特点：

- 是面向连接的
- 可靠交付的
- 点对点的
- 全双工的
- 字节流形式的

和UDP区别：

- UDP不面向连接
- UDP不提供可靠交付
- UDP可一对一、一对多、多对一、多对多
- UDP面向报文
- UDP首部为8字节，TCP为20字节
- UDP不支持拥塞控制

TCP用于对通信可靠性有要求的场景，比如HTTP、HTTPS、FTP这种传输文件的协议，以及SMTP等；UDP一般用于语音、视频这类通信，对可靠性要求不高

### :point_right:TCP拆包、粘包？如何解决？

TCP拆包：

- 要发送的数据大于发送端缓冲区的大小
- 发送的数据包大小大于MSS*（Maximum Segment Size）*，会进行拆包

TCP粘包：

- 接收端的应用没有及时接收缓冲区的数据
- 发送的数据包小于发送缓冲区的大小，多个数据包一起发送了

解决：*（都是上层应用层面提供的）*

- 发送端将数据包封装成固定大小，避免小于或大于缓冲区，累计读取到长度和为定长LEN的报文后，就认为读取到了一个完整的信息
- 应用端制定通信协议，用特殊的字段标识，后面根据字段进行数据包的重组
- 通过在消息头中定义长度字段来标识消息的总长度

### :point_right:TCP拥塞控制？

TCP拥塞控制是为了防止通信的双方不知道网络的具体情况，导致数据传输过程中产生网络拥塞状况。拥塞控制有这样几种算法：慢开始、拥塞避免、快重传、快恢复

- 慢开始：TCP发送报文的时候，一开始因为不知道网络的拥塞状况，所以采用逐步增加的策略。所以一开始拥塞窗口cwnd大小初始化为1，然后逐步增加，每一个RTT后乘2
- 拥塞避免：达到慢门限阈值ssthresh=16后，每一个RTT后加1，如果某次发生了拥塞，则ssthresh设置为当前的一半，重新慢开始
- 快重传：传统方式下，接收方收到失序报文，不作处理，发送端等到重传超时之后进行重传，不过这样会影响效率。在快重传算法下，接收方会重复发送丢失序号的报文的ACK，发送端接连收到三个这样的ACK时，可以认定报文丢失，立即进行重传
- 快恢复：在接收端连续收到三次重复ACK，进入快恢复，cwnd大小变为一半，并每一个RTT后加1

### :point_right:TCP滑动窗口？

TCP接收端处理速度如果小于发送端发送的速度，会造成数据的拥塞、粘包或者是丢失，需要根据接收端的缓冲区大小来确定发送端发送数据的速率，可以靠滑动窗口来控制。可以分为这样几个部分：

**发送端**

- 窗口外：
  - 发送了且收到确认的
  - 不能发送的
- 窗口内：
  - 发送了但未收到确认的
  - 根据接收端缓冲区大小计算出的还可以发送的但仍未发送的

发送了但未收到确认的数据包收到ACK之后，窗口就可以向右滑动，发送新的包

**接收端**

接收端也有窗口，分为：

- 接收到但还没有被进程处理的
- Advertised Window，大小在TCP报文头指定：
  - 收到但还未发送确认的
  - 未收到的

接收端将Advertised Window大小发送给发送端，发送端根据这个大小控制滑动窗口的大小

### :point_right:讲讲HTTP协议？报文格式？

HTTP协议是运行在网络层之上的协议，它是一种无状态的协议，可以传输Content-Type指定类型的任意数据

**请求报文格式为：**

- 请求行：GET/POST/PUT/DELETE等
- 请求头：User-Agent/Accept/Host/Connection/Cookie/Content-Type/Content-Length/Authorization等
- 空行
- 请求体

**响应报文格式为：**

- 状态行：协议版本/状态码/状态描述信息
- 响应头：Content-Type/Set-Cookie等
- 空行
- 响应体

### :point_right:TCP、UDP报头格式？

**TCP报头（>=20字节）：**

- 第一行
  - 源端口、目的端口（16bits）
- 第二行
  - 序列号（seq，32bits）
- 第三行
  - 确认号（ack，32bits）
- 第四行
  - 数据偏移（4bits，最大偏移量为15*4bytes=60bytes）
  - 保留位、标志位（ACK、SYN、FIN、URG）
  - 窗口大小（16bits）
- 第五行
  - 校验和（16bits）
  - 紧急指针（16bits）
- 剩余（不超过40字节）
  - 可选字段
  - 填充

**UDP报头（8字节）：**

- 源端口号
- 目的端口号
- 长度
- 校验和

### :point_right:HTTP状态码？

- 1xx：服务端接收到客户端请求，要求客户端进行进一步处理*（对客户端不可见）*

  - 101：切换协议

    比如客户端要求建立webSocket连接，首先发送一个普通的HTTP请求，其中的Connection字段为Connection: Upgrade，并且包含一个Upgrade: websocket字段。服务端收到后，会返回101状态码，并建立websocket连接

- 2xx：请求成功

  - 200：请求成功，请求的数据体随此响应返回
  - 201：请求成功，服务器根据请求创建了新的资源，通常是PUT/POST
  - 202：请求接受，但还未处理

- 3xx：重定向

  - 301：请求的资源移动到别处，永久重定向，会缓存
  - 302：临时重定向，不会缓存

- 4xx：客户端错误

  - 400：请求语法/参数错误
  - 401：请求登录后才能访问的资源时返回该状态码，要求身份验证
  - 403：理解了请求，但并未授权
  - 404：请求的资源未找到，或服务端不愿透露
  - 405：请求方法错误

- 5xx：服务端错误

  - 500：服务器不知如何处理
  - 502：服务器作为网关，从上游服务器收到了无效的响应
  - 503：由于服务器维护或过载，**暂时**无法提供服务

### :point_right:HTTP1.0和1.1区别？

HTTP 1.0是默认短连接的，可以修改请求头为Connection:keep-alive，HTTP 1.1是默认长连接的，客户端可以复用这个连接，不过前一个请求阻塞了，可能导致后面的也阻塞，出现队头阻塞问题

HTTP 1.0不支持断点续传，HTTP 1.1支持断点续传

HTTP 1.1比1.0多了24种错误状态码

HTTP 1.1比HTTP 1.0请求头多了Host信息，用于支持虚拟机等等

### :point_right:HTTP1.1和2.0区别？

- HTTP 2.0是二进制流传输的，支持二进制分帧，一个请求可以分帧并行传输，不用按顺序依次处理，通过帧头打标签确定属于哪一个流和保证顺序，解决队头阻塞问题；1.1是文本格式的，会队头阻塞
- HTTP 2.0是支持服务端主动推送的，1.1不支持
- HTTP 2.0分为头部帧、数据帧，支持头部压缩；对于重复数据可以支持不重复传

### :point_right:HTTP和HTTPS区别？

HTTP是无加密传输的，未验证身份，容易被冒充或中间人篡改，HTTPS是加密传输的，运行在ssl之上，需要向CA机构申请证书

HTTP是80端口，HTTPS是443端口

### :point_right:什么是数字证书？

数字证书是网络进行加密通信的双方提供的验证身份的一系列数据，包括证书内容、签名算法以及数字签名。数字证书需要向通信双方信赖的第三方CA机构申请

数字证书的创建和验证流程是这样的：

- 创建：CA根据证书内容，首先通过hash算法计算出hash值，接着使用自己的私钥对这个hash值进行加密，得到数字签名
- 验证：浏览器根据数字证书，首先拿到数字签名，接着通过从CA处获得的公钥对签名进行解密，再hash运算，比对这一个hash值和对证书内容进行hash运算的结果是否一致，一致则证书合法

### :point_right:HTTPS原理？

首先客户端服务端建立TCP连接，接着客户端发送建立HTTPS的请求：

1. 首先客户端发送client hello*（基于SSL协议，content-type为handshake，包含数据时为record）*，其中包含了客户端支持的加密算法列表、客户端TSL协议版本、要访问的域名等
2. 接着服务端响应server hello，发送所选择的加密算法
3. 接着服务端发送证书，证书内容包括一对公钥和私钥、网站地址、证书颁发日期、失效日期等
4. 客户端验证证书的合法性，如果验证合法，浏览器则会随机生成一个对称密钥*（session key）*，并用公钥加密，发送给服务端
5. 服务端通过私钥解密对称密钥，后续的通信都通过这个对称密钥来进行加密解密

### :point_right:DNS的解析过程？

首先浏览器在自己的DNS缓存中搜索有没有域名对应的IP，如果没有，则在操作系统的DNS缓存和hosts文件中搜索，还没有则提交给本地域名服务器搜索，没搜索到则从根域名服务器开始搜索，再到顶级域名服务器，再到权威域名服务器，层层都做缓存，最后返回给本地域名服务器

### :point_right:浏览器输入URL的返回过程？

首先需要对URL进行解析，接着通过域名找到对应的IP，浏览器以随机端口向80端口建立三次握手TCP连接，接着浏览器发送HTTP请求，服务端返回HTTP响应，浏览器根据响应的数据进行解析并且渲染，呈现给用户

### :point_right:网络通信的过程？

以一次HTTP通信为例，首先需要通过三次握手建立TCP连接；建立TCP连接首先需要通过网络层进行网络数据包的传输，IP头有源IP和目的IP，路由器根据路由表进行路由转发；路由转发需要链路层的支持，通过arp协议获得目的ip的设备mac，进行数据帧的传输；又需要用到底层物理层进行真实的数据传递

### :point_right:Cookie和Session的区别？

cookie是一段存储在客户端本地的小型文档，记录了访问某web的一些信息，再次访问该页面的时候可以用上这些信息；session是服务端存储的一个对象，可用于存放一个会话期间需要的信息。区别在于：

- cookie保存在客户端，session保存在服务端
- cookie可以保存较长时间，session在客户端连接断开或超时之后就会失效
- cookie存储能力有限，不能超过4k，session不设限制

### :point_right:TCP和HTTP的长连接有什么区别？

HTTP长连接本质上是靠TCP实现的，TCP长连接是靠心跳机制实现的，靠socket封装的
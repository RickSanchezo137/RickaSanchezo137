# [返回](/)

# 八股文背诵版之—JVM篇

## 基础知识

:point_right:**知道深拷贝和浅拷贝吗？**

知道。对一个对象的拷贝，浅拷贝对其基本数据类型的属性和引用类型属性的地址都是进行值传递的，因此，两个对象中相对应的引用类型的属性会指向同一个内存地址；深拷贝对其基本数据类型进行值传递，对引用类型创建一个全新的对象，并复制其内容，因此两个对象中对应的引用类型的属性，会指向不同的内存地址。Object的clone()方法是浅拷贝，需要对其进行重写实现深拷贝

![image-20220105164902566](imgs\JVM\2.png)

:point_right:**讲一下JVM主要组成部分？**

> 两个子系统（类加载、执行引擎）、两个组件（运行时数据区、本地方法接口）

JVM主要由类加载子系统、执行引擎、运行时数据区和本地方法接口来组成

其中类加载子系统用于将二进制Class文件或运行过程中动态生成的字节码加载到内存中去，主要包括类的装载，链接、初始化这三个步骤；执行引擎主要用于对字节码文件采用模板解释器进行逐行解释；运行时数据区用于存放Java运行过程中的各种数据及结构；本地方法接口用于在Java程序内调用本地方法

<img src="imgs\JVM\1.png" alt="JVM架构" style="zoom: 67%;" />

:point_right:**讲一下运行时数据区？**

> 规范划分为**五个**区域

运行时数据区用于存放Java程序运行过程中的各种数据及数据结构，主要包括堆、虚拟机栈、本地方法栈、程序计数器以及方法区这几个组成部分

- 堆是线程共享的区域，主要用于存放Java中的各种实例对象，创建新对象的内存**几乎**都是在堆上分配的

- 虚拟机栈是线程私有的，主要用于方法的调用，每次方法调用，对应产生一个虚拟机栈中的栈帧，一个栈桢包括局部变量表、操作数栈、动态链接、方法返回地址

- 本地方法栈是线程私有的，对应线程中调用的本地方法，在hotspot中与虚拟机栈合二为一

- 程序计数器是线程私有的，用于存储程序运行时下一条指令的地址，程序的分支、循环、跳转、异常跳转等功能都是靠它实现，字节码解释器通过修改程序计数器的值来选取下一条需要执行的指令（根据指令类型不同有所不同，可以在取指阶段计算长度就能知道，也可能是需要根据指令内容来计算）
- 方法区是线程共享的，主要用于存放各种元信息，包括类元信息、方法信息、CodeCache及运行时常量池等

:point_right:**为什么pc寄存器要线程私有？**

PC寄存器需要保存线程执行到哪一条指令了，线程在执行过程中可能由于时间片轮转把cpu让给其他线程而暂停执行，恢复执行的时候需要从上次执行到的位置继续往下执行，如果这一区域共享了，就不容易保存上次运行到的位置了，线程之间会互相干扰

:point_right:**堆栈的区别？**

- 内存：堆的内存不是连续分配的，栈的内存是连续分配的
- 线程共享/私有：堆是共享的，栈是私有的
- 抛出异常：堆抛出OOM异常；不支持栈动态扩展的话，栈深度超过某一阈值会报SOF，支持的话则可能由于内存不足报OOM

:point_right:**对象实例化过程？**

> 6个步骤

调用new方法在堆中创建一个对象，① 首先会检查类是否加载完成，没有的话则进行类的加载。② 接着会在堆上分配内存，如果内存是规整的，即是通过标记压缩算法整理的，则采用指针碰撞法来分配内存；否则通过空闲列表法分配内存。③ 在分配内存时也要考虑并发问题，首选通过TLAB给每个线程分配私有的缓冲区，在缓冲区上分配，分配失败后可以通过CAS来避免冲突。④ 接着会对分配到的空间进行初始化，主要是给成员变量赋零值等。⑤ 然后设置对象头。⑥ 最后调用\<init>初始化，包括显式初始化、代码块初始化、构造器初始化等

:point_right:**知道句柄访问吗？**

知道。hotspot中采用的是直接访问，栈中的引用指向堆中的实例对象地址，实例对象头中的klass pointer指向方法区的类元信息，如果发生GC对对象进行移动，栈中引用指向的地址也要随之改变，但速度快，能够一次访问到对象。而句柄访问是在堆中句柄池中创建一个句柄，包括一个指向实例对象地址的指针和一个指向类元信息的指针，并令栈中的引用指向这个句柄地址；GC移动对象后，只需要改变句柄中指向实例对象的指针，而不需要去改变栈中的引用，缺点是要消耗更多空间，并且访问对象时要多一次步骤

<img src="imgs\JVM\3.png" alt="image-20210822223548563" style="zoom:33%;" />

:point_right:**java内存泄漏的场景？**

长生命周期对象持有短生命周期对象的引用，导致短生命周期对象迟迟不能被回收，这就是内存泄漏。典型场景有threadlocal，如果不作清空操作，线程中一直有一个以null为键的Entry迟迟不能被回收，线程持续多久这个Entry就要持续多久

## 类加载

:point_right:**java类加载过程？**

java类加载包括三个步骤，类的装载、链接和初始化。其中装载是根据类的全限定名将二进制Class文件或动态生成的字节码加载到内存当中，将静态结构转换成内存中运行的数据结构，并且在堆中生成一个对应的Class对象。链接包括验证、准备和解析，验证阶段会对字节码的合法性进行校验，包括魔数头校验等等；准备阶段会对类变量进行零值初始化，解析阶段会将部分常量池中的符号引用转换成直接引用；初始化阶段会调用\<clinit>方法对类变量进行显式初始化并执行静态代码块

:point_right:**java有哪几种类加载器？**

1. BootstrapClassloader，即启动类加载器，是最顶层的一个加载器，负责加载java的核心类库，即%JAVA_HOME%/jre/lib路径或

   `-Xbootclasspath`指定的路径下的jar包，比如rt.jar

2. ExtClassLoader，扩展类加载器，用来加载%JAVA_HOME%/jre/lib/ext路径或-Djava.ext.dirs指定路径下的jar包

3. AppClassLoader，应用类加载器，用来加载Classpath路径下或-Djava.class.path指定路径下的jar包或Class文件

4. 用户自定义类加载器，通过继承java.lang.ClassLoader来实现

:point_right:**讲一下双亲委派机制模型？**

当一个类加载器接收到加载一个类的请求，首先不会自己去加载这个类，而是先委托给父类的加载器进行加载，最终所有的请求都会被传达到启动类加载器，只有发现当父类加载器无法实现加载的时候，子类才会去尝试加载该类

> 扩展：JDK9后会先进行模块化加载。加载一个类时，首先根据类名找到所在的模块，再使用模块对应的类加载器进行加载，通过这样的手段，能够大大减小Java程序打包的体积，比如将rt.jar拆分成多个模块。同时大大提高加载效率
>
> 只有找不到对应模块时，才会调用双亲委派机制来加载

:point_right:**双亲委派机制作用？**

是Java的沙箱安全机制，首先可以防止类被重复加载，父类能加载，子类就不必加载；其次可以防止核心类库被任意覆盖，比如对于核心类库来说，我们肯定希望Java程序在各个环境下加载的都是同一个核心类，如果没有安全委派机制，用户命名一个同名的类，然后用自己的类加载器加载，造成程序中出现多个同名但不相同的类，造成混乱

:point_right:**讲一下双亲委派机制破坏？**

通过继承ClassLoader类并重写loadClass方法来破环。原生的loadClass方法首先会调用findLoadedClass(String name)方法检查类是否被加载，如果没有，则递归调用parent.loadClass方法，如果parent为null，就到了启动类加载器了，就会使用启动类加载器加载，如果父类加载失败返回null，则会由子类逐层调用findClass方法，在findClass中如果找到对应字节码资源，则调用defineClass方法字节码转换成Class对象并返回，实现加载，这就是双亲委派的逻辑。因此，打破双亲委派一定要重写loadClass方法

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }

            if (c == null) {
                long t1 = System.nanoTime();
                c = findClass(name);

                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

> 如果要正常实现一个满足双亲委派的自定义类加载器，只需要重写findClass方法就好。调用父类的loadClass最终都会调用到这个findClass方法

## GC

:point_right:**什么是GC？**

在Java程序中，程序员并不需要手动去进行内存管理与垃圾回收，而是交给JVM来管理。JVM中有一个低优先级的垃圾回收线程，在内存不足时会启动垃圾回收过程来对无用的内存空间进行回收，有效防止了内存泄漏，降低了程序员的工作量

:point_right:**GC原理？**

首先JVM会申请一个Stop The World，对内存空间中的GC Roots进行枚举；接着基于GC Roots进行可达性分析，将GC Roots引用链上的对象标记为可达对象；对于不可达的对象，如果没有重写finalize方法，则直接回收，否则加入F-Queue队列，并由低优先级的Finalizer线程调用队列中对象的finalize方法；之后再判断对象是否可达，如果不可达，直接回收，如果可达，对象复活，但被标记为finalized状态，也就是已经调用过finalize的状态，下次GC时如果不可达，就直接回收

:point_right:**你提到了GC Roots，什么是GC Roots？**

GC Roots是一组当前时刻保持活跃的对象集合，一般包括虚拟机栈/本地方法栈中的引用指向的对象、静态变量指向的对象、常量指向的对象等等

:point_right:**怎么判断对象能否被回收？**

1. 引用计数法，有指向对象的引用，则计数加一，若不再指向它了，则计数减一，最后计数为0时则可以回收，缺点是无法解决循环引用的问题
2. 可达性分析，会基于GC Roots进行可达性分析，不可达且未重写finalize方法的直接回收；重写了finalize方法的对象会被加入F-Queue队列中等待Finalizer线程调用它的finalize方法

:point_right:**你知道哪些垃圾回收算法？**

1. 标记清除算法，首先标记不可达对象，接着回收不可达对象的内存。优点是垃圾回收效率较高，缺点是会产生大量不好整理的内存碎片，不便于后续分配大对象
2. 标记复制算法，将GC一次后的这一区域存活对象复制到另一个区域，并回收该区域所有内存空间，接着互换这两个空间的角色。优点是不产生内存碎片，缺点是会浪费多一份内存空间，复制并移动对象需要更改指向它的引用，如果存活对象多，则开销会很大
3. 标记压缩算法，GC后将对象整理到整个内存区域的一边，使其保持连续性。优点在于不会浪费多一份内存空间，不会有内存碎片，缺点是对存活的对象都要在内存中进行整理，开销大
4. 分代算法，根据对象的生命周期分为不同的代，比如Hotspot堆区的新生代、老年代，提高回收效率
5. 分区算法，将内存区域分为若干个小的分区，以区为单位进行垃圾回收
6. 增量收集，gc时用户线程和垃圾回收线程并发，减少用户线程停顿时间

:point_right:**你知道哪些垃圾回收器？**



## 调优






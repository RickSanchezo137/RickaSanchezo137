# [返回](/)

# 初级-1

## 时间复杂度

遍历+比较+交换的次数

取高阶抛弃低阶

## 异或

交换a、b的值

```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

对于arr[i] ^ arr[i]，由于内存地址相同，直接抹成0了，因此不能采用这种写法

> 相当于a = arr[i]，b = arr[i]，a ^ b之后，a、b的值都改变了

### 算法题

#### 1. 找奇数次数

> 1. 数组中有一个数出现了奇数次，其他都出现了偶数次，如何以时间复杂度O(N)、空间复杂度O(1)找出这个数

解：用一个变量，从头异或到尾，就可以

*偶数次的数之间异或，只剩下0；奇数次的数之间异或，最后只剩下那个奇数*

```java
public int find(int[] arr){
    int eor = 0;
    for(int i = 0; i < arr.length; i++){
        eor = eor ^ arr[i];
    }
    return eor;
}
```

#### 2. 找两个奇数次数

> 2. 有两个数出现了奇数次，怎么找？

解：设这两个数是a、b ① 用eor遍历数组，最后eor的结果一定是a ^ b ② 如果eor在某一位上为1，则表明要么是a的这一位上为1，要么是b的这一位上为1 ③ 将所有这一位上为1的，单独放到一个集合里面，再用eor2异或这个集合里面的数，偶数次的全部消掉了，剩下的只有a或b，即eor2==a或b ④ 用eor2异或eor，就能得到另外一个数

```java
public int[] find(int[] arr){
    int eor = 0, eor2 = 0, index = -1;
    for(int i = 0; i < arr.length; i++){
        eor ^= arr[i];
    }
    while(eor >> ++index != 1);
    for(int i = 0; i < arr.length; i++){
        if(arr[i] >> index == 1){
            eor2 ^= arr[i];
        }
    }
    return new int[]{eor2, eor ^ eor2};
}
```

改进写法：

```java
public int[] find(int[] arr){
    int eor = 0, eor2 = 0, base;
    for(int i = 0; i < arr.length; i++){
        eor ^= arr[i];
    }
    // 提取eor最右边的1
    /* 如    eor == 10110010
            ~eor == 01001101
          ~eor+1 == 01001110
    eor&(~eor+1) == 00000010
    倒数第二位的1就被分离出来
    */
    base = eor & (~eor + 1); 
    for(int i = 0; i < arr.length; i++){
        // (arr[i] & base) == 0，说明arr[i]在这个位上为0；(arr[i] & base) == base，说明为1
        if((arr[i] & base) == 0){
            eor2 ^= arr[i];
        }
    }
    return new int[]{eor2, eor ^ eor2};
}
```

## 二分法

> 针对于有序数组，降到O(logN)

### 具体数字

> 对于某个有序数组arr，找出数组中是否存在某个数字target

解：二分法最基础的应用

```java
public boolean binarySearch(int[] arr, int target){
    int lo = 0, hi = arr.length - 1;
    while(lo <= hi){
        int mid = lo + ((hi - lo) >> 1);
        if(target > arr[mid]){
            lo = mid + 1;
        }else if(target < arr[mid]){
            hi = mid - 1;
        }else return true;
    }
    return false;
}
```

### 某个范围

> 对于某个有序数组arr，找出数组中满足>=target的最左边的数字的索引

解：取mid的值，如果mid满足>=target，就在<=mid的范围找；否则在>mid的范围找

```java
public int binarySearchOnCondition(int[] arr, int target){
    int lo = 0, hi = arr.length - 1;
    while(lo < hi){
        int mid = lo + ((hi - lo) >> 1);
        if(arr[mid] >= target){
            hi = mid;
        }else lo = mid + 1;
    }
    return lo;
}
```

### 局部最小值

> 对于无序数组arr，相邻的值不相同，找出一个局部最小的位置，使用好于O(N)的方法（*比相邻的两个值都小，0位置的话是比右边小，最后一个位置的话是比左边小*）

解：① 先判断0位置是不是局部最小，若是，直接返回；②  判断n-1位置是不是局部最小，若是，直接返回；③如果上面两个条件都不成立，说明0到n-1之间一定有一个局部最小值，因为中间一定会存在若干个拐点

![image-20210517163811432](imgs\左神算法课\1.png)

取mid，如果mid是局部最小，直接返回，如果mid不是局部最小，若mid>mid-1，则0到mid-1一定存在局部最小值；同理若mid>mid+1，则mid到n-1一定存在局部最小值

![image-20210517164651968](imgs\左神算法课\2.png)

```java
public int binarySearchForLocalMinimum(int[] arr){
    int lo = 0, hi = arr.length - 1;
    if(arr[lo] <= arr[lo + 1]) return lo;
    if(arr[hi] <= arr[hi - 1]) return hi;
    while(lo < hi){
        int mid = lo + (lo + (hi - lo) >> 1);
        if(arr[mid] <= arr[mid - 1] && arr[mid] <= arr[mid + 1]) return mid;
        else if(arr[mid] > arr[mid - 1]) hi = mid;
        else lo = mid;
    }
    return lo;
}
```

> 很多地方都可以使用二分策略，需要仔细思考

# 初级-2

## 递归

### 时间复杂度

#### master公式

<img src="imgs\左神算法课\3.png" alt="image-20210728102938338" style="zoom: 50%;" />

以求数组最大值为例

```java
static int process(int[] arr, int lo, int hi){
    if(lo == hi) return arr[lo];
    int mid = lo + ((hi - lo) >> 1);
    int leftMax = process(arr, lo, mid), rightMax = process(arr, mid + 1 , hi);
    return Math.max(leftMax, rightMax);
}
```

子问题分成两部分，所以b = 2；一次leftMax，一次rightMax，所以a = 2；O(N^d) = 第一行比较+第二行移位+第四行return = O(1)

T(N) = 2*T(N/2) + O(1)

**公式成立前提：子问题规模一致！**

#### 时间复杂度

基于master公式

- 若$log_ba<d$，则时间复杂度为$O(N^d)$
- 若$log_ba>d$，则时间复杂度为$O(N^{log_ba})$
- 若$log_ba=d$，则时间复杂度为$O(N^d*logN)$

以刚才的为例，时间复杂度为O(N)

## 归并排序

```java
static void mergeSort(int[] arr){
    sort(arr, 0, arr.length - 1);
}
static void sort(int[] arr, int lo, int hi){
    if(lo == hi) return;
    int mid = lo + ((hi - lo) >> 1);
    sort(arr, lo, mid);
    sort(arr, mid + 1, hi);
    merge(arr, lo, hi);
}
static void merge(int[] arr, int lo, int hi){
    int[] helpArr = new int[hi - lo + 1];
    int mid = lo + ((hi - lo) >> 1), index1 = lo, index2 = mid + 1;
    for(int i = lo; i <= hi; i++){
        helpArr[i - lo] = (index1 <= mid && (index2 > hi || arr[index1] <= arr[index2]))? arr[index1++]: arr[index2++];
    }
    for(int i = lo; i <= hi; i++){
        arr[i] = helpArr[i - lo];
    }
}
```

$T(N)=2*log(N/2)+O(N)$满足master公式，其中a = 2，b = 2，d = 1，$log_ba=d$

时间复杂度 = O(NlogN)

### 算法题

#### 1. 求数组“小和”

> 1. 求数组“小和”，例如[2, 4, 5, 1, 3, 1]。遍历，4左边有2比4小，5左边有2、4比5小，1没有，3左边有2、1比3小，1没有
>
> 加起来的值：2 + 2+4 + 0 + 2+1 + 0 = 11，即为“小和” 

当然可以通过遍历来计算小和，但这样就是$O(N^2)$的复杂度了，实际上，可以通过归并思想，达到$O(NlogN)$

> 从2开始，2右边有4、5、3比2大，会产生3个2的小和，4右边有5，会产生1个4的小和，5没有，1右边有3，会产生1个1的小和，3没有，1没有，3\*2+1\*4+0+1\*1+0+0=11
>
> 而右边比左边大的数量，不用遍历，可以直接通过归并来求

```java
static int getSmallSum(int[] arr, int lo, int hi){
    if(lo == hi) return 0;
    int mid = lo + ((hi - lo) >> 1);
    return getSmallSum(arr, lo, mid) +
    getSmallSum(arr, mid + 1, hi) +
    merge(arr, lo, mid, hi);
}
static int merge(int[] arr, int lo, int mid, int hi){
    int[] helpArr = new int[hi - lo + 1];
    int index1 = lo, index2 = mid + 1, smallSum = 0;
    for(int i = lo; i <= hi; i++){
        // 求merge时的小和，arr[index1] * 会包含arr[index1]的小和个数
        smallSum += index1 <= mid && index2 <= hi && arr[index1] < arr[index2] ? arr[index1] * (hi - index2 + 1) : 0;
        // 注意这里，两边相等时一定要先移动右边的指针，否则就无法判断右边的包含arr[index1]的小和个数了
        helpArr[i - lo] = index1 <= mid && (index2 > hi || arr[index1] < arr[index2]) ? arr[index1++] : arr[index2++];
    }
    for (int i = lo; i <= hi; i++){
        arr[i] = helpArr[i - lo];
    }
    return smallSum;
}
```

> 主要核心思想在于：每次merge时，各个分组里面的小和已经算好了，所以再加上merge的就可以，不会重算，也不会漏算

#### 2. 打印所有逆序对

> 2. 打印所有逆序对。数组中左边的数如果比右边的大，则称为一个逆序对

```java
static void printReverse(int[] arr, int lo, int hi){
    if(lo == hi) return;
    int mid = lo + ((hi - lo) >> 1);
    printReverse(arr, lo, mid);
    printReverse(arr, mid + 1, hi);
    merge(arr, lo, mid, hi);
}
static void merge(int[] arr, int lo, int mid, int hi){
    int[] helpArr = new int[hi - lo + 1];
    int index1 = lo, index2 = mid + 1;
    for(int i = lo; i <= hi; i++){
        if(index1 > mid) helpArr[i - lo] = arr[index2++];
        else if(index2 > hi) helpArr[i - lo] = arr[index1++];
        else if(arr[index1] <= arr[index2]) helpArr[i - lo] = arr[index1++];
        // 此时，出现第一个逆序对
        // 已知merge两边的各分组都已经排好序了，且已经打印逆序对了
        // 所以arr[index1, mid]都能和arr[index2]构成逆序对
        else {
            for (int j = index1; j <= mid; j++) {
                System.out.println("[" + arr[j] + ", " + arr[index2] + "]");
            }
            helpArr[i - lo] = arr[index2++];
        }
    }
    for(int i = lo; i <= hi; i++){
        arr[i] = helpArr[i - lo];
    }
}
```

> 核心思想在于：只需要考虑merge时的逆序对，每个分组里面已经排好序了，不可能有逆序对

## 快速排序

### 算法题

#### 1. 荷兰国旗一

![image-20210728164233471](imgs\左神算法课\4.png)

```java
static void exchange(int[] arr, int num){
    for(int i = 0, j = arr.length - 1; i <= j;){
        while (i >= 0 && arr[i] <= num) i++;
        while (j < arr.length && arr[j] > num) j--;
        if(i >= j) break;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

#### 2. 快速排序1.0

普通快排

```java
static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
static int partition(int[] arr, int lo, int hi){
    int pivot = arr[lo], i, j;
    for(i = lo + 1, j = hi;;){
        while (i < hi && arr[i] < pivot) i++;
        while (j > lo && arr[j] >= pivot) j--;
        if(i >= j) break;
        swap(arr, i, j);
    }
    // 这里，要么满足j == lo，要么满足arr[j] < pivot，于是交换j和lo
    swap(arr, lo, j);
    return j;
}
static void sort(int[] arr, int lo, int hi){
    if(lo >= hi) return;
    int pivotIndex = partition(arr, lo, hi);
    sort(arr, lo, pivotIndex - 1);
    sort(arr, pivotIndex + 1, hi);
}
```

#### 3. 快速排序2.0

划分成<、=、>三个部分

```java
static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
/**
 * 维护三个移动的指针lt、gt、i
 * 其中，[lo, lt)都小于pivot
 * [lt~i)都等于pivot
 * [i~gt]未处理
 * (gt, hi]都大于pivot
 */
static int[] partition(int[] arr, int lo, int hi){
    int pivot = arr[lo], lt, gt, i;
    for(lt = lo, i = lo + 1, gt = hi; i <= gt;){
        // [lt, i)随着遇到pivot相等值，不断扩张，也就是说[lt, i - 1]上一定是pivot相等值
        // i与lt交换，原本的i上变成了pivot相等值，lt变成小于pivot的值，再一起++，但[lt+1, i]上仍都是pivot相等值
        // 因此，同时++，仍能满足[lt, i - 1]上一定是pivot相等值
        if(arr[i] < pivot) swap(arr, lt++, i++);
        // gt未知，换过来的不知道是啥，所以[lt, i)不能扩张
        else if(arr[i] > pivot) swap(arr, i, gt--);
        else i++;
    }
    return new int[]{lt, gt};
}
static void sort(int[] arr, int lo, int hi){
    if(lo >= hi) return;
    int[] pivotIndex = partition(arr, lo, hi);
    sort(arr, lo, pivotIndex[0] - 1);
    sort(arr, pivotIndex[1] + 1, hi);
}
```

#### 4. 快速排序3.0

随机选取pivot

```java
static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
static int[] partition(int[] arr, int lo, int hi){
    // 选择随机index，并与lo交换
    int randomIndex = lo + new Random().nextInt(hi - lo + 1);
    swap(arr, lo, randomIndex);
    int pivot = arr[lo], lt, gt, i;
    for(lt = lo, i = lo + 1, gt = hi; i <= gt;){
        if(arr[i] < pivot) swap(arr, lt++, i++);
        else if(arr[i] > pivot) swap(arr, i, gt--);
        else i++;
    }
    return new int[]{lt, gt};
}
static void sort(int[] arr, int lo, int hi){
    if(lo >= hi) return;
    int[] pivotIndex = partition(arr, lo, hi);
    sort(arr, lo, pivotIndex[0] - 1);
    sort(arr, pivotIndex[1] + 1, hi);
}
```

# 初级-3

## 堆排序

### heapInsert

```java
static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
// 大顶堆，尾节点上浮
static void heapInsert(int[] arr, int index){
    while(index > 0 && arr[index] > arr[index - 1 >> 1]){
        swap(arr, index, index - 1 >> 1);
        index = index - 1 >> 1;
    }
}
```

### 排序

```java
static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
static void heapInit(int[] arr){
    // two ways
    for(int i = arr.length - 1 >> 1; i >= 0; i--){
        heapify(arr, i, arr.length);
    }
    // or
    for(int i = 0; i < arr.length; i++){
        heapInsert(arr, i);
    }
}
// 下沉
static void heapify(int[] arr, int index, int bound){
    int leftSon = (index << 1) + 1, rightSon = leftSon + 1;
    if(leftSon >= bound) return;
    int bigger = rightSon >= bound || arr[leftSon] > arr[rightSon] ? leftSon : rightSon;
    if(arr[bigger] < arr[index]) return;
    swap(arr, index, bigger);
    heapify(arr, bigger, bound);
}
static void heapSort(int[] arr){
    heapInit(arr);
    for(int i = arr.length - 1; i > 0; i--){
        swap(arr, i, 0);
        heapify(arr, 0, i);
    }
}
```

> 如果中间某个数突然变了怎么处理？（大根堆）
>
> 如果变小了，就和子结点比并下沉；如果变大了，就和父节点比并上浮

### 优先队列

> 是一个默认的小根堆结构
>
> 注意在寻找最小/最大值的时候，学会采用优先队列的方法

### 算法题

#### 1. 数组的基本有序

> 1. 令数组基本有序，且每个元素移动的距离不超过k

基本思路，k个构造一个小根堆，弹出最小值，并接着添加进后面一个，周而复始

```java
static void almostSort(int[] arr, int k){
    PriorityQueue<Integer> heap = new PriorityQueue<>(k);
    int i = 0, index = 0;
    for(; i < arr.length; i++){
        if(i >= k)
            arr[index++] = heap.poll();
        heap.add(arr[i]);
    }
    while(!heap.isEmpty()) arr[index++] = heap.poll();
}
```

#### 2. 数据流的中位数

> 2. 数据流的中位数：要求能够实时返回数据流的中位数

```java
public static double medium(int[] arr){
    PriorityQueue<Integer> bHeap = new PriorityQueue<>(new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
        }
    });
    PriorityQueue<Integer> sHeap = new PriorityQueue<>();
    for (int a: arr){
        if (!bHeap.isEmpty() && a > bHeap.peek()) sHeap.offer(a);
        else bHeap.offer(a);
        if (bHeap.size() > sHeap.size() + 1) sHeap.offer(bHeap.poll());
        else if (sHeap.size() > bHeap.size() + 1) bHeap.offer(sHeap.poll());
    }
    if (sHeap.size() == bHeap.size()) return (sHeap.peek() + bHeap.peek()) / 2.0;
    else if (sHeap.size() > bHeap.size()) return sHeap.peek();
    else return bHeap.peek();
}
```

## 不基于比较的排序

### 算法题

#### 1. 员工年龄排序

> 1. 员工年龄排序，年龄在18~60之间

基本思路，采用年龄出现频次统计，计数排序

```java
static void ageSort(int[] arr){
    int[] helpArr = new int[60 - 18 + 1];
    for(int e: arr){
        helpArr[e - 18]++;
    }
    for(int i = 0, index = 0; i < helpArr.length; i++){
        for(int j = 0; j < helpArr[i]; j++){
            arr[index++] = i + 18;
        }
    }
}
```

> 可延展到一定确定范围（小范围）内数的排序

### 基数排序(桶排序)

![img](imgs\radixSort.gif?lastModify=1627544491)

创建十个桶，从个位开始，将所有数放入对应的桶，每个桶可看作一个队列，先入先出，遍历桶拿出所有的数，这样个位就有序了

接着看十位、百位、千位......，最终做到全部有序

```java
static void bucketSort(int[] arr){
    int max = Arrays.stream(arr).max().getAsInt();
    int digits = getDigits(max);
    for(int i = 1; i <= digits; i++){
        int[] count = new int[10];
        int[] help = Arrays.copyOf(arr, arr.length);
        for(int j = 0; j < arr.length; j++){
            count[getReverseDigit(help[j], i)]++;
        }
        for(int j = 1; j < 10; j++){
            count[j] += count[j - 1];
        }
        for(int j = arr.length - 1; j >= 0; j--){
            arr[--count[getReverseDigit(help[j], i)]] = help[j];
        }
    }
}
static int getDigits(int num){
    int i = 0;
    for(; num != 0; num /= 10, ++i);
    return i;
}
static int getReverseDigit(int num, int digit){
    for(int i = 1; i < digit; i++) num /= 10;
    return num % 10;
}
```

### 稳定性

> 作用：第一次根据某个属性排序；第二次根据另一个属性排序，同时力求保持住根据上一个属性排序的顺序，这样，第二个属性的数据中在第一个属性上也是有序的

> 目前，还不存在时间复杂度$O(NlogN)$，空间复杂度为$O(1)$，且能保持稳定的排序

### 补充知识

- 01 sort，快排中，左边放的都是<=pivot或<pivot，右边都是>pivot或>=pivot，这是一个01问题

> 类似的可以扩展成：奇数放左边，偶数放右边，等等
>
> 01 stable sort是可以实现的，只不过空间复杂度会提升到O(N)，有相关论文

- 综合排序

```java
final static int THRESHOLD = 6;
static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
static int[] partition(int[] arr, int lo, int hi){
    int randomIndex = lo + new Random().nextInt(hi - lo + 1);
    swap(arr, lo, randomIndex);
    int pivot = arr[lo], lt, gt, i;
    for(lt = lo, i = lo + 1, gt = hi; i <= gt;){
        if(arr[i] < pivot) swap(arr, lt++, i++);
        else if(arr[i] > pivot) swap(arr, i, gt--);
        else i++;
    }
    return new int[]{lt, gt};
}
static void sort(int[] arr, int lo, int hi){
    if(hi - lo + 1 <= THRESHOLD){
        // 插入排序常数项小，小样本时速度快
        insertSort(arr, lo, hi);
    }
    if(lo >= hi) return;
    int[] pivotIndex = partition(arr, lo, hi);
    sort(arr, lo, pivotIndex[0] - 1);
    sort(arr, pivotIndex[1] + 1, hi);
}
static void insertSort(int[] arr, int lo, int hi){
    for(int i = lo + 1; i <= hi; i++){
        for(int j = i; j > lo; j--){
            if(arr[j] < arr[j - 1]){
                swap(arr, j, j - 1);
            }else break;
        }
    }
}
```

# 初级-4

## 链表

### 方法论

![image-20210730142846119](D:\笔记\秋招\docs\算法\imgs\左神算法课\5.png)

### 算法题

#### 1. 反转单链表

> 1. 反转单链表
>
> ```java
> class Node{
>     Node(){}
>     Node(int val){this.val = val;}
>     int val;
>     Node next;
> }
> ```

反转问题，一般都可以用栈

```java
static Node reverseByStack(Node head){
    Stack<Node> stack = new Stack<>();
    for(; head != null; head = head.next){
        stack.push(head);
    }
    Node newHead = stack.isEmpty() ? null : stack.pop();
    Node p = newHead;
    while(!stack.isEmpty()){
        Node n = stack.pop();
        p.next = n;
        n.next = null;
        p = p.next;
    }
    return newHead;
}
```

更优雅的写法，用递归，jvm自己压方法栈

```java
/**
 * 首先确定方法的作用，即返回反转后链表的头节点
 * head.next指向的就变成了反转链表的尾节点
 * 于是令head.next.next = head，自己成为尾节点
 * 同时令head.next = null
 * @param head
 * @return
 */
static Node reverse(Node head){
    // 说明递归到之前的尾节点了，直接返回，作为头
    if(head == null || head.next == null) return head;
    Node reverseHead = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return reverseHead;
}
```

迭代法练习

```java
static Node reverse(Node head){
    Node prev = null, curr = head, pred = null;
    while(curr != null){
        pred = curr.next;
        curr.next = prev;
        prev = curr;
        curr = pred;
    }
    return prev;
}
```

#### 2. 反转双向链表

> 2. 反转双向链表

```java
static Node reverse(Node head){
    if(head.next == null) return head;
    Node reverseHead = reverse(head.next);
    head.prev = head.next;
    head.next.next = head;
    head.next = null;
    return reverseHead;
}
```

#### 3. 判断是否为回文链表

> 3. 判断是否为回文链表
>
> ```java
> class Node{
>     Node(){}
>     Node(int val){this.val = val;}
>     int val;
>     Node next;
> }
> ```

1. 压栈，空间复杂度O(N)

```java
static boolean isPalindromic(Node head){
    Stack<Node> stack = new Stack<>();
    Node p = head;
    for(; p != null; p = p.next)
        stack.push(p);
    for(; !stack.isEmpty(); head = head.next){
        if(stack.pop().val != head.val)
            return false;
    }
    return true;
}
```

2. 快慢指针+一半压栈，空间复杂度O(N/2)

```java
static boolean isPalindromic(Node head){
    Stack<Node> stack = new Stack<>();
    Node slow = head, fast = head;
    for(; fast != null && fast.next != null; fast = fast.next.next, slow = slow.next);
    // 此时fast跳完，slow跳到中间位置或中间位置的后一个
    for(; slow != null; slow = slow.next)
        stack.push(slow);
    for(; !stack.isEmpty(); head = head.next){
        if (stack.pop().val != head.val)
            return false;
    }
    return true;
}
```

3. 快慢指针，空间复杂度O(1)

```java
static boolean isPalindromic(Node head){
    Node slow = head, fast = head;
    for(; fast != null && fast.next != null; fast = fast.next.next){
        if(fast.next.next != null) slow = slow.next;
    }
    // 此时fast跳完，slow跳到中间位置或中间位置的前一个
    Node midHead = reverse(slow.next);
    // 记录中间位置的头节点对应链表反转之后的头节点
    Node temp = midHead;
    for(; temp != null; temp = temp.next, head = head.next){
        if(temp.val != head.val){
            // 恢复原链表
            slow.next = reverse(midHead);
            return false;
        }
    }
    // 恢复原链表
    slow.next = reverse(midHead);
    return true;
}
```

#### 4. 链表划分

> 4. 链表划分，给定一个pivot，小于pivot的划分到左边，等于的划分到中间，大于的划分到右边

1. 使用辅助数组

```java
static Node divideChain(int pivot, Node head){
    ArrayList<Node> list = new ArrayList<>();
    // 依此放入数组
    for(; head != null; head = head.next)
        list.add(head);
    Node[] arr = list.toArray(new Node[0]);
    // 快排三向切分变式
    int lt = 0, i = Math.min(1, arr.length), gt = arr.length - 1;
    boolean visited = arr[lt].val == pivot;
    while (i <= gt){
        if (arr[i].val < pivot) swap(arr, lt++, i++);
        else if(arr[i].val > pivot) swap(arr, i, gt--);
        else {
            // 第一次遇到相等节点时，lt++，保证lt位置的值与pivot相等
            if(!visited){
                lt++;
                visited = true;
            }
            i++;
        }
    }
    for(i = 0; i < arr.length - 1; i++){
        arr[i].next = arr[i + 1];
        arr[i + 1].next = null;
    }
    return arr[0];
}
```

2. 临时变量

小于部分的头、尾；等于部分的头、尾；大于部分的头、尾

```java
static Node divideChain(int pivot, Node head){
    Node sh = null, st = null, eh = null, et = null, bh = null, bt = null;
    for(; head != null; head = head.next) {
        if (head.val < pivot){
            if(st == null){
                sh = st = head;
            }else {
                st.next = head;
                st = st.next;
            }
        }else if (head.val > pivot){
            if(bt == null){
                bh = bt = head;
            }else {
                bt.next = head;
                bt = bt.next;
            }
        }else{
            if(et == null){
                eh = et = head;
            }else {
                et.next = head;
                et = et.next;
            }
        }
    }
    // 这一步很重要！！！
    bt.next = null;
    if(st != null) {
        if(et != null) {
            st.next = eh;
            et.next = bh;
        }else st.next = bh;
        return sh;
    }else {
        if(et != null){
            et.next = bh;
            return eh;
        }
        return bh;
    }
}
```

#### 5. 特殊链表复制

![image-20210730164511994](imgs\左神算法课\6.png)

1. 使用哈希表

```java
static Node copy(Node head){
    HashMap<Node, Node> map = new HashMap<>();
    Node p = head;
    for(; p != null; p = p.next){
        Node newNode = new Node();
        map.put(p, newNode);
    }
    p = head;
    for(; p != null; p = p.next){
        Node temp = map.get(p);
        temp.val = p.val;
        temp.next = map.get(p.next);
        temp.rand = map.get(p.rand);
    }
    return map.get(head);
}
```

2. 使用原链表

将哈希表的一一映射关系反映在链表当中，令原节点指向新节点，最后再分离开来

```java
static Node copy(Node head){
    if(head == null) return null;
    Node p = head;
    for(; p != null; p = p.next.next){
        Node temp = p.next;
        p.next = new Node(p.val);
        p.next.next = temp;
    }
    p = head;
    // 这一步一定要跟下一步分开，否则在random指针往回指的时候会出错！
    for(; p != null; p = p.next.next){
        if(p.rand != null) p.next.rand = p.rand.next;
    }
    Node newHead = head.next;
    Node newP = newHead;
    p = head;
    for(; p != null && newP.next != null; p = p.next, newP = newP.next){
        // 下面这两步的先后顺序很重要！
        p.next = p.next.next;
        newP.next = newP.next.next;
    }
    // 保证原链表不变
    p.next = null;
    return newHead;
}
```

#### 6. 有环链表的入口节点

> 6. 有环链表的入口节点。判断是否为有环链表，如果是，返回其入口节点

1. 使用哈希表

```java
static Node findLoopEnter(Node head){
    HashSet<Node> set = new HashSet<>();
    for(; head != null; head = head.next){
        if(set.contains(head)) return head;
        set.add(head);
    }
    return null;
}
```

2. 快慢指针

```java
/**
 * 假设环之前那一段距离为 x，环的周长为 r
 * 当快慢指针相遇时，假设慢指针在环内离入口的距离为 y，还要移动 r - y 能再次到达入口
 * 这时快指针肯定比慢指针多在环内跑了若干圈
 * 即，slow经过的路程：s = x + y；fast经过的路程：f = x + y + nr
 * 又∵ f = 2 * s，2x + 2y = x + y + nr
 * x + y = nr，r - y = r - nr + x = x - (n - 1)r
 * ∴ 慢指针还需移动 r - y 再次到达入口，接着再移动若干圈，能够达到总距离为 x
 * 所以此时，另一个指针从起点开始移动 x，此时慢指针移动了 r - y + (n - 1)r，一定在入口处相遇
 * 返回入口节点
 */
static Node findLoopEnter(Node head){
    Node slow = head.next, fast = head.next.next;
    for (;; fast = fast.next.next, slow = slow.next){
        if(fast == null || fast.next == null) return null;
        if(fast == slow) break;
    }
    fast = head;
    for(;; fast = fast.next, slow = slow.next){
        if(slow == fast) return slow;
    }
}
```

#### 7. 相交链表的入口节点

> 7. 寻找相交链表的入口节点并返回，如果没有相交则返回null

1. 使用哈希表

```java
static Node findIntersection(Node head1, Node head2){
    HashSet<Node> set = new HashSet<>();
    for (; head1 != null; head1 = head1.next){
        set.add(head1);
    }
    for (; head2 != null; head2 = head2.next){
        if(set.contains(head2)) return head2;
    }
    return null;
}
```

2. 指针

```java
/**
 * 两个链表的指针同时移动，其中一个先到终点，此时，另一个指针距离终点的距离就是两条链表的长度差值
 * 令到终点的指针回到另一个长链表的链表头
 * 同时移动，这个指针就移动了这个差值
 * 此时令一个指针从另一条链表头开始移动，最终，会同时移到交叉处
 */
static Node findIntersection(Node head1, Node head2){
    Node p1 = head1, p2 = head2;
    for(; p1 != null && p2 != null; p1 = p1.next, p2 = p2.next);
    // 链表2比1长
    if(p1 == null){
        p1 = head2;
        for(; p2 != null; p1 = p1.next, p2 = p2.next);
        p2 = head1;
    }else {
        p2 = head1;
        for(; p1 != null; p1 = p1.next, p2 = p2.next);
        p1 = head2;
    }
    for(; p1 != null && p2 != null; p1 = p1.next, p2 = p2.next){
        if(p1 == p2) return p1;
    }
    return null;
}
```

#### 8. 相交链表的入口节点2.0

> 8. 寻找相交链表的入口节点并返回，如果没有相交则返回null，注意，这两个链表，可能有环，也可能无环

分析情况：

<img src="imgs\左神算法课\7.png" alt="image-20210802150140848" style="zoom: 50%;" />

对于情况1，直接返回enter；对于2，返回环的两个入口节点其中一个；对于情况3，将环的入口当作链表末尾来处理

```java
static Node findIntersection(Node head1, Node head2, Node end){
    Node p1 = head1, p2 = head2;
    for(; p1 != end && p2 != end; p1 = p1.next, p2 = p2.next);
    // 链表2比1长
    if(p1 == end){
        p1 = head2;
        for(; p2 != end; p1 = p1.next, p2 = p2.next);
        p2 = head1;
    }else {
        p2 = head1;
        for(; p1 != end; p1 = p1.next, p2 = p2.next);
        p1 = head2;
    }
    for(; p1 != end && p2 != end; p1 = p1.next, p2 = p2.next){
        if(p1 == p2) return p1;
    }
    return null;
}
static Node findLoopEnter(Node head){
    Node slow = head.next, fast = head.next.next;
    for (;; fast = fast.next.next, slow = slow.next){
        if(fast == null || fast.next == null) return null;
        if(fast == slow) break;
    }
    fast = head;
    for(;; fast = fast.next, slow = slow.next){
        if(slow == fast) return slow;
    }
}
static Node findIntersection2(Node head1, Node head2){
    Node loopNode1 = findLoopEnter(head1), loopNode2 = findLoopEnter(head2);
    if(loopNode1 != loopNode2) return loopNode1;
    return findIntersection(head1, head2, loopNode1.next);
}
```

# 初级-5

## 二叉树

### 树的遍历

> 所有递归都可以改成非递归，一个是系统压栈，一个是自己压栈

```java
class Node<T>{
    T value;
    Node left;
    Node right;
    public Node() {}
    public Node(T value) {
        this.value = value;
    }
}
```

#### 前序

1. 递归

```java
static void preorderTraversal(Node root){
    if (root == null) return;
    System.out.print(root.value + " ");
    preorderTraversal(root.left);
    preorderTraversal(root.right);
}
```

2. 非递归

```java
static void preorderTraversal(Node root){
    if(root == null) return;
    Stack<Node> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        // 头节点一弹出来就处理
        Node head = stack.pop();
        System.out.print(head.value + " ");
        // 右子树先进栈后处理
        if (head.right != null) stack.push(head.right);
        // 左子树后进栈先处理
        if (head.left != null) stack.push(head.left);
    }
}
```

#### 中序

1. 递归

```java
static void inorderTraversal(Node root){
    if (root == null) return;
    inorderTraversal(root.left);
    System.out.print(root.value + " ");
    inorderTraversal(root.right);
}
```

2. 非递归

每个树都可以按照“左(右)边界”来划分

![image-20210803162651393](imgs\左神算法课\8.png)

不停取左节点，就可以取到头节点和左节点，整体分为“左边界”，“右叶子结点”两部分

```java
static void inorderTraversal(Node root){
    if (root == null) return;
    Stack<Node> stack = new Stack<>();
    stack.push(root);
    Node p = root;
    while (!stack.isEmpty()){
        // p所在的左边界压栈
        if(p.left != null) {
            stack.push(p = p.left);
            continue;
        }
        // 弹出一个左边界的节点并显示
        Node leftOrHead = stack.pop();
        System.out.print(leftOrHead.value + " ");
        // 如果左边界中某个节点有右子树，则压栈
        if(leftOrHead.right != null) stack.push(p = leftOrHead.right);
    }
}
```

#### 后序

1. 递归

```java
static void postorderTraversal(Node root){
    if (root == null) return;
    postorderTraversal(root.left);
    postorderTraversal(root.right);
    System.out.print(root.value + " ");
}
```

2. 非递归

需要做到 left→right→head，需要把head放在后面处理，如果在第一个循环内打印head，就做不到head后处理了

可以用一个结果栈来接收head，然后后面再处理

```java
static void postorderTraversal(Node root){
    if (root == null) return;
    Stack<Node> stack = new Stack<>(){{
        push(root);
    }};
    Stack<Node> printStack = new Stack<>();
    while(!stack.isEmpty()){
        Node head = stack.pop();
        // head先进栈后处理
        printStack.push(head);
        if (head.left != null) stack.push(head.left);
        // right会先进printStack，后处理
        if (head.right != null) stack.push(head.right);
    }
    while (!printStack.isEmpty()){
        System.out.print(printStack.pop().value + " ");
    }
}
```

#### 层次

> 使用队列

```java
static void levelTraversal(Node root){
    if (root == null) return;
    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()){
        Node head = queue.poll();
        System.out.print(head.value + " ");
        if(head.left != null) queue.offer(head.left);
        if(head.right != null) queue.offer(head.right);
    }
}
```

### 算法题

#### 1. 树的最大宽度

1. 遍历并记录每一层的宽度

```java
static final HashMap<Integer, Integer> levelCounter = new HashMap<>();
static int maxWeight(Node root){
    count(root, 1);
    System.out.println(levelCounter);
    int max = 0;
    for (Map.Entry<Integer, Integer> entry: levelCounter.entrySet()){
        max = entry.getValue() > max ? entry.getValue() : max;
    }
    return max;
}
static void count(Node root, int level){
    if(root == null) return;
    levelCounter.put(level, levelCounter.get(level) == null ? 1 : levelCounter.get(level) + 1);
    count(root.left, level + 1);
    count(root.right, level + 1);
}
```

2. 也可以直接用map记录节点层数，并使用层次遍历

```java
static int maxWeight(Node root){
    if(root == null) return 0;
    // 记录最大宽度和当前层的宽度, 以及当前层数
    int max = 0, currentLevelNodes = 0, currentLevel = 1;
    HashMap<Node, Integer> levelMap = new HashMap<>();
    Queue<Node> queue = new LinkedList<>();
    levelMap.put(root, currentLevel);
    queue.offer(root);
    while (!queue.isEmpty()){
        Node node = queue.poll();
        if (levelMap.get(node).equals(currentLevel)){
            currentLevelNodes++;
        }else {
            // 如果get到的层数和currentLevel不一致，则说明到了下一层，进行清算
            max = Math.max(max, currentLevelNodes);
            currentLevelNodes = 0;
            currentLevel++;
        }
        if (node.left != null) {
            queue.offer(node.left);
            levelMap.put(node.left, currentLevel + 1);
        }
        if (node.right != null) {
            queue.offer(node.right);
            levelMap.put(node.right, currentLevel + 1);
        }
    }
    return max;
}
```

3. 也可以去掉map，以每层的最后一个节点，作为清算点

```java
static int maxWeight(Node root){
    if(root == null) return 0;
    // 记录最大宽度和当前层的宽度
    int max = 0, currentLevelNodes = 0;
    // 记录下一层的end节点和这一层的end节点
    Node nextLevelEnd = root.right != null ? root.right :
    	root.left != null ? root.left : null, currentLevelEnd = root;
    if (nextLevelEnd == null) return 1;
    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()){
        Node node = queue.poll();
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
        if (currentLevelEnd != node){
            currentLevelNodes++;
        }else {
            // 到这里说明已经到这一层的最后一个节点了，该跳入下一层了
            max = Math.max(max, currentLevelNodes + 1);
            // 因为跳到下一层了，所以令这一层的end节点等于下一层的end节点
            currentLevelEnd = nextLevelEnd;
            // 没有下一层了，直接返回结果
            if(currentLevelEnd == null) return max;
            // 下一层的end节点，是这一层的end节点的子结点(层序遍历下)
            nextLevelEnd = currentLevelEnd.right != null ? currentLevelEnd.right :
            	currentLevelEnd.left != null ? currentLevelEnd.left : null;
            currentLevelNodes = 0;
        }
    }
    return max;
}
```

#### 2. 判断是否为搜索二叉树

> 2. 判断一棵树是否为搜索二叉树

基本思路：中序遍历，始终递增就为搜索二叉树

```java
static boolean isBinary(Node root){
    return isBinary(root, Integer.MIN_VALUE);
}
static boolean isBinary(Node root, int max){
    if(root == null) return true;
    boolean flag1, flag2 = true, flag3;
    flag1 = isBinary(root.left, max);
    if(root.value < max) {
        flag2 = false;
    }
    max = root.value;
    flag3 = isBinary(root.right, max);
    return flag1 && flag2 && flag3;
}
```

#### 3. 判断是否为完全二叉树

> 3. 判断一棵树是否为完全二叉树

层次遍历

(1) 如果有右子树，则必须要有左子树

(2) 在不违反(1)的情况下，如果遇到某一个节点不是左右子树都有，则后续的节点必须都为叶子节点

```java
static boolean isComplete(Node root){
    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    boolean flag = false;
    while (!queue.isEmpty()){
        Node node = queue.poll();
        if (node.right != null && node.left == null) return false;
        if (flag && !(node.left == null && node.right == null)) return false;
        flag = node.left == null || node.right == null;
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }
    return true;
}
```

#### 4. 判断是否为满二叉树

> 4. 判断一棵树是否为满二叉树

注意，满二叉树必须满足一个性质：假设节点数为n，最大深度为l，必须满足$2^l-1=n$才叫满二叉树

```java
static boolean isFull(Node root){
    return (1 << depth(root)) - 1 == size(root);
}
static int depth(Node root){
    if(root == null) return 0;
    return 1 + Math.max(depth(root.left), depth(root.right));
}
static int size(Node root){
    if(root == null) return 0;
    return size(root.left) + 1 + size(root.right);
}
```

#### 5. 判断是否为平衡二叉树

> 5. 判断一棵树是否为平衡二叉树

```java
static boolean isBalanced(Node root){
    return isBalanced(root.left) 
        && isBalanced(root.right) 
        && Math.abs(depth(root.left) - depth(root.right)) <= 1;
}
static int depth(Node root){
    if(root == null) return 0;
    return 1 + Math.max(depth(root.left), depth(root.right));
}
```

### 树的递归套路：树形DP

**确定向左子树要什么信息，向右子树要什么信息**

以搜索二叉树为例，首先需要左右子树是否为搜索二叉树的信息

其次，需要满足左子树的最大值小于当前值，右子树的最小值大于当前值，所以需要要到左子树的最大值信息以及右子树的最小值信息

```java
static int max(Node root){
    if(root == null) return Integer.MIN_VALUE;
    return Math.max(Math.max(max(root.left), root.value), max(root.right));
}
static int min(Node root){
    if(root == null) return Integer.MAX_VALUE;
    return Math.min(Math.min(min(root.left), root.value), min(root.right));
}
static boolean isBinary(Node root){
    if(root == null) return true;
    return isBinary(root.left)
            && max(root.left) <= root.value && min(root.right) >= root.value
            && isBinary(root.right);
}
```

另一种通用一点的写法，相当于只递归了一次

```java
static class ReturnInfo{
    boolean isBinary;
    int min;
    int max;
    public ReturnInfo(boolean isBinary, int min, int max) {
        this.isBinary = isBinary;
        this.min = min;
        this.max = max;
    }
}
static ReturnInfo process(Node root){
    ReturnInfo returnInfo = new ReturnInfo(true, Integer.MAX_VALUE, Integer.MIN_VALUE);
    if(root == null) return returnInfo;
    ReturnInfo leftInfo = process(root.left), rightInfo = process(root.right);
    returnInfo.max = Math.max(Math.max(leftInfo.max, rightInfo.max), root.value);
    returnInfo.min = Math.min(Math.min(leftInfo.min, rightInfo.min), root.value);
    returnInfo.isBinary = leftInfo.isBinary
            && leftInfo.max <= root.value && rightInfo.min >= root.value
            && rightInfo.isBinary;
    return returnInfo;
}
static boolean isBinary(Node root){
    return process(root).isBinary;
}
```

#### 6. 最低公共祖先

> 6. 给出树中的两个节点，找出他们的最低公共祖先节点

1. 使用哈希表

用set存放两节点其中一个的所有祖先，接着遍历另一个节点所有父节点，看看在不在set里面，返回在里面的第一个

```java
static Node lowestCommonAncestor(Node head, Node n1, Node n2){
    HashMap<Node, Node> fatherMap = new HashMap<>();
    HashSet<Node> n1Father = new HashSet<>();
    inorderTraversal(head, fatherMap);
    for (Node n = n1; n != head;){
        n1Father.add(n = fatherMap.get(n));
    }
    for (Node n = n2; n != head;){
        if(n1Father.contains(n = fatherMap.get(n))) return n;
    }
    return null;
}
static void inorderTraversal(Node head, HashMap<Node, Node> fatherMap){
    if(head == null) return;
    if(head.left != null) fatherMap.put(head.left, head);
    if(head.right != null) fatherMap.put(head.right, head);
    inorderTraversal(head.left, fatherMap);
    inorderTraversal(head.right, fatherMap);
}
```

2. 递归

遇到两节点其中一个就返回，否则返回null，如果某个节点两分支的返回结果都不为null，说明这是公共祖先

```java
static Node lowestCommonAncestor(Node head, Node n1, Node n2){
    // 如果在某个分支找到n1或n2，就一直向上返回；否则返回null
    if(head == null || head == n1 || head == n2) return head;
    // 左分支的返回结果
    Node leftAns = lowestCommonAncestor(head.left, n1, n2);
    // 右分支的返回结果
    Node rightAns = lowestCommonAncestor(head.right, n1, n2);
    // 两边都有返回结果，说明在两个分支里找到了n1，n2
    if(leftAns != null && rightAns != null){
        return head;
    }
    // 只有一边有返回结果，不停向上返回；两边都没有，就返回null
    return leftAns != null ? leftAns : rightAns;
}
```

#### 7. 找出中序遍历的后继结点

> 7. 提供一个parent指针，以更好的效率找出节点中序遍历的后继节点
>
> ```java
> class Node{
>     int value;
>     Node left;
>     Node right;
>     Node parent;
>     public Node() {}
>     public Node(int value) {
>         this.value = value;
>     }
> }
> ```

两种情况：

1. 节点有右子树，那么它的后继结点就是右子树的最左节点
2. 节点没有右子树
   1. 节点有右parent，则为右parent
   2. 节点没有右parent，向上寻找自己的parent直到出现右parent

注意特殊情况，最右边的节点没有后继节点

```java
static Node findSuccessor(Node node){
    if (node == null) return null;
    if (node.right != null) return findMostLeft(node.right);
    for (; node.parent != null && node.parent.left != node; node = node.parent);
    return node.parent;
}
static Node findMostLeft(Node node){
    if (node.left == null) return node;
    return findMostLeft(node.left);
}
```

#### 8. 树的序列化和反序列化

> 8. 实现树序列化成一个字符串，再反序列化回来

注意要记录null就可

```java
// 基于先序遍历
// 序列化
static StringBuilder sb = new StringBuilder();
static String serialize(Node head){
    if(head == null) {
        sb.append("#_");
        return null;
    }
    sb.append(head.value + "_");
    serialize(head.left);
    serialize(head.right);
    return sb.toString();
}


// 反序列化
static int index;
static Node deserialize(String str){
    String[] nodeStrArr = str.split("_");
    return process(nodeStrArr);
}
static Node process(String[] strArr){
    if (index == strArr.length || "#".equals(strArr[index])) return null;
    Node newNode = new Node(Integer.parseInt(strArr[index]));
    ++index;
    newNode.left = process(strArr);
    ++index;
    newNode.right = process(strArr);
    return newNode;
}
```

#### 9. 折纸问题

> 9. 折纸问题
>
> 一张纸，面对自己，对折N次，产生的折痕方向有向自己方向的，也有向反方向的，从上到下打印折痕的方向

实验：

<img src="imgs\左神算法课\9.png" alt="image-20210805093023483" style="zoom:50%;" />

实际上，这很像一棵二叉树

![image-20210805093632206](imgs\左神算法课\10.png)

右子树全为凸，左子树全为凹

```java
static void printDirect(int N){
    Node root = init(N, true);
    print(root);
}
// true和1代表凹，false和0代表凸
static Node init(int N, boolean direct){
    if (N == 0) return null;
    int value = direct ? 1 : 0;
    Node node = new Node(value);
    node.left = init(N - 1, true);
    node.right = init(N - 1, false);
    return node;
}
static void print(Node root){
    if(root == null) return;
    print(root.left);
    System.out.println(root.value == 1 ? "凹" : "凸");
    print(root.right);
}
```

# 初级-6

## 图

> 小技巧：图的表达形式太多，可以转换成自己熟悉的表达图的方式，再使用在这种图上熟悉的算法

### 通用基本结构

```java
class Node{
    int value;
    int in;  // 入度
    int out;  // 出度
    ArrayList<Node> nexts;  // next节点集
    ArrayList<Edge> edges;  // 节点连接的边
}
class Edge{
    int weight;
    Node from;
    Node to;
}
class Graph{
    HashMap<Integer, Node> nodes;
    HashSet<Edge> edges;
}
```

### 遍历

#### 广度优先遍历

```java
static void BFS(Node root){
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> visited = new HashSet<>();
    visited.add(root);
    queue.offer(root);
    while(!queue.isEmpty()){
        Node node = queue.poll();
        System.out.print(node.value + " ");
        for (Node next: node.nexts){
            if (!visited.contains(next)){
                visited.add(next);
                queue.offer(next);
            }
        }
    }
}
```

#### 深度优先遍历

```java
static void DFS(Node root){
    if (root == null) return;
    Stack<Node> stack = new Stack<>();
    HashSet<Node> visited = new HashSet<>();
    stack.push(root);
    visited.add(root);
    System.out.print(root.value + " ");
    while (!stack.isEmpty()){
        Node node = stack.pop();
        for(Node next: node.nexts){
            if(!visited.contains(next)){
                stack.push(node);
                stack.push(next);
                visited.add(next);
                System.out.print(next.value + " ");
                break;
            }
        }
    }
}
```

### 拓扑排序

> 常用场景：某些工作之前，必须完成它的前置工作，比如，依赖的编译时

给出一个有向无环图，确定其拓扑排序

基本方法，找出所有入度为0的点，擦掉它及它的影响，再循环这个过程

```java
static List<Node> topology(Graph graph){
    HashMap<Node, Integer> inMap = new HashMap<>();
    ArrayList<Node> topologyResult = new ArrayList<>();
    Queue<Node> queue = new LinkedList<>();
    for (Node node: graph.nodes.values()){
        inMap.put(node, node.in);
        if(node.in == 0) queue.offer(node);
    }
    while (!queue.isEmpty()){
        Node node = queue.poll();
        for (Node n: node.nexts){
            // 当前节点的next节点入度减一
            int in;
            inMap.put(n, in = inMap.get(n) - 1);
            if (in == 0) queue.offer(n);
        }
        topologyResult.add(node);
    }
    return topologyResult;
}
```

### 最小生成树

> 令无向图各点连通，且权值之和最小

#### k算法：kruskal

令图一开始没有边，从权值最小的边开始，如果不会形成环，往里加；否则不加

找出权值最小边对应的两个顶点在不在一个连通块里面，如果不在，则合并

> 自己之前写的是如果点不在这个集合里面，就加进去；否则不加，实际上大错特错
>
> 比如{A, B}和{C, D}，现在A、C之间有一条边，按这个方法，就没法加了
>
> prim可以这样加，因为prim不会出现两个分开的连通块

1. 普通写法

```java
static Set kruskal(Graph graph){
    Set<Edge> result = new HashSet<>();
    // 堆，用来找最小边
    PriorityQueue<Edge> heap = new PriorityQueue<>(Comparator.comparingInt(o -> o.weight));
    HashMap<Node, ArrayList<Node>> map = new HashMap<>();
    heap.addAll(graph.edges);
    for (Node node: graph.nodes.values()){
        // 首先每个节点自己作为一个连通块
        map.put(node, new ArrayList<>(){{add(node);}});
    }
    while (!heap.isEmpty()){
        Edge edge = heap.poll();
        // 边的两个节点不在同一连通块，合并
        if (map.get(edge.from) != map.get(edge.to)){
            union(edge.from, edge.to, map);
            result.add(edge);
        }
    }
    return result;
}
// 连通块求并集
static void union(Node from, Node to, HashMap<Node, ArrayList<Node>> map){
    ArrayList<Node> fromSet = map.get(from), toSet = map.get(to);
    fromSet.addAll(toSet);
    map.put(to, fromSet);
}
```

2. 并查集写法

#### p算法：prim

从点开始找，不断加入点集，找距离点集最近的边

```java
static Set prim(Graph graph){
    Set<Edge> result = new HashSet<>();
    Set<Node> visited = new HashSet<>();
    PriorityQueue<Edge> heap = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));
    for (Node node: graph.nodes.values()){
        if(!visited.contains(node)){
            visited.add(node);
            // 加入当前节点的所有边
            heap.addAll(node.edges);
            while (!heap.isEmpty()){
                Edge minEdge = heap.poll();
                Node to = minEdge.to;
                // 每加入一个点，就把它的所有边放到堆里，这样就可以找点集的最小边
                if (!visited.contains(to)){
                    visited.add(to);
                    result.add(minEdge);
                    heap.addAll(to.edges);
                }
            }
        }
    }
    return result;
}
```

### 最短路径

#### dijkstra

```java
static HashMap<Node, Integer> dijkstra(Node root){
    //  建立距离表
    HashMap<Node, Integer> distanceMap = new HashMap<>();
    HashSet<Node> selected = new HashSet<>();
    distanceMap.put(root, 0);
    Node minNode = null;
    //  从没处理的节点中选取距离源最短的
    while ((minNode = getMinWeightFromUnselected(distanceMap, selected)) != null){
        int distance = distanceMap.get(minNode);
        Node toNode = null;
        //  看看距离源最短的节点到其他节点的距离
        //  如果距离源最短的节点的距离+到其他节点的距离 < 其他节点到源的距离，则替换
        for (Edge edge: minNode.edges){
            if (!distanceMap.containsKey(toNode = edge.to)){
                distanceMap.put(toNode, distance + edge.weight);
            }
            distanceMap.put(toNode, Math.min(distanceMap.get(toNode), distance + edge.weight));
        }
        //  处理过的节点，不再处理
        selected.add(minNode);
    }
    return distanceMap;
}

// 此处可以用堆加速
static Node getMinWeightFromUnselected(HashMap<Node, Integer> distanceMap, HashSet<Node> selected){
    Node minNode = null;
    int minWeight = Integer.MAX_VALUE;
    for (Map.Entry<Node, Integer> entry: distanceMap.entrySet()){
        if (!selected.contains(entry.getKey())){
            if (minWeight > entry.getValue()){
                minWeight = entry.getValue();
                minNode = entry.getKey();
            }
        }
    }
    return minNode;
}
```

> 前提：没有权值为负数的边

# 初级-7

## 字符串前缀树

```java
import java.util.Arrays;

public class TrieTreeTest {
    public static void main(String[] args) {
        TrieTree trieTree = new TrieTree();
        String[] strings = {"word", "world", "wolf", "women", "wtf", "word", "word", "wtf"};
        Arrays.stream(strings).forEach(trieTree::add);
        //
        System.out.println(trieTree.search("word"));
        //
        System.out.println(trieTree.has("women"));
        //
        System.out.println(trieTree.findPrefixNum("wo"));
        //
        trieTree.delete("word");
        System.out.println(trieTree.search("word"));
    }
}
@SuppressWarnings("all")
class TrieTree{
    private Integer pass = 0;
    private Integer end = 0;
    private TrieTree[] next;

    /**
     * 给前缀树添加一个字符串
     * @param str
     */
    public void add(String str){
        if(next == null){
            next = new TrieTree[26];
        }
        char[] chs = str.toCharArray();
        TrieTree temp = this;
        for (char ch: chs){
            ++temp.pass;
            if (temp.next == null) temp.next = new TrieTree[26];
            if (temp.next[ch - 'a'] == null) temp.next[ch - 'a'] = new TrieTree();
            temp = temp.next[ch - 'a'];
        }
        ++temp.end;
    }

    /**
     * 统计某个词出现的次数
     * @param str
     * @return
     */
    public int search(String str){
        TrieTree temp = this;
        char[] chs = str.toCharArray();
        for (char ch: chs){
            if ((temp = temp.next[ch - 'a']) == null) {
                return 0;
            }
        }
        return temp.end;
    }

    public boolean has(String str){
        return search(str) > 0;
    }

    /**
     * 统计有多少个词以prefix为前缀
     * @param prefix
     * @return
     */
    public int findPrefixNum(String prefix){
        TrieTree temp = this;
        char[] chs = prefix.toCharArray();
        for (char ch: chs) {
            if ((temp = temp.next[ch - 'a']) == null) {
                return 0;
            }
        }
        return temp.pass;
    }

    /**
     * 从前缀树中删除一个字符串
     * @param str
     */
    public void delete(String str){
        if (!has(str)) return;
        TrieTree temp = this;
        char[] chs = str.toCharArray();
        for (char ch: chs){
            --temp.pass;
            temp = temp.next[ch - 'a'];
        }
        --temp.end;
    }
}
```

## 贪心算法

### 解图套路

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、贪心策略B、贪心策略C...
3. 用解法X和对数器，去验证每-一个贪心策略，用实验的方式得知哪个贪心策略正确
4. 不要去纠结贪心策略的证明

> 常用技巧：
>
> - 根据某标准建立一个比较器来排序
> - 根据某标准建立一个比较器来建堆

### 算法题

#### 1. 会议安排

![image-20210823102914861](imgs\左神算法课\11.png)

基本思路：先安排结束时间最早的

```java
@AllArgsConstructor
@Data
static class Program{
    private Integer start;
    private Integer end;
}
static class ProgramComparator implements Comparator<Program>{
    @Override
    public int compare(Program o1, Program o2) {
        return o2.end - o1.end;
    }
}
public static int bestArrange(Program[] programs, int timePoint){
    Arrays.sort(programs, new ProgramComparator());
    int result = 0;
    for (Program program: programs){
        if (program.start >= timePoint){
            result++;
            timePoint = program.end;
        }
    }
    return result;
}
```

#### 2. 字符串最小字典序拼接

> 2. 字符串拼接，使得拼接后的字典序最小
>
> 字典序：a < b; apple < b; bad < bbc

```java
static class StringComparator implements Comparator<String>{
    @Override
    public int compare(String o1, String o2) {
        return (o1 + o2).compareTo(o2 + o1);
    }
}
public static String concatDueToDictOrder(String... strings){
    Arrays.sort(strings, new StringComparator());
    StringBuilder sb = new StringBuilder();
    for (String str: strings){
        sb.append(str);
    }
    return sb.toString();
}
```

#### 3. 分金条

![image-20210823115456920](imgs\左神算法课\12.png)

基本思路：哈夫曼编码问题

```java
public static int minCost(int[] arr){
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for (int a: arr) pq.add(a);
    int res = 0;
    while (!pq.isEmpty()){
        int o1 = pq.poll();
        if (pq.isEmpty()) return res;
        int o2 = pq.poll();
        res += o1 + o2;
        pq.add(res);
    }
    return res;
}
```

#### 4. N皇后问题

> 4. N皇后问题：将 n个皇后放置在 n×n的棋盘上，并且使皇后彼此之间不能相互攻击，即任何两个皇后都不能处于同一条横行、纵行或斜线上，返回所有解
>
> [力扣链接](https://leetcode-cn.com/problems/n-queens/)

```java
public List<List<String>> solveNQueens(int n) {
    List<List<String>> ans = new ArrayList<>();
    process(0, n, new int[n], ans);
    return ans;
}
public void process(int layer, int n, int[] points, List<List<String>> ans){
    if(layer == n) {
        List<String> solve = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[points[i]] = 'Q';
            solve.add(new String(row));
        }
        ans.add(solve);
        points = new int[n];
    }
    for(int col = 0; col < n; col++){
        if(isValid(layer, col, points)){
            points[layer] = col;
            process(layer + 1, n, points, ans);
        }
    }
}
public boolean isValid(int xx, int yy, int[] points){
    if(points.length == 0) return true;
    for(int x = 0; x < xx; x++){
        int y = points[x];
        if(y == yy || (xx - x == Math.abs(yy - y))) return false;
    }
    return true;
}
```

位运算优化版

```java
public List<List<String>> solveNQueens(int n) {
    List<List<String>> ans = new ArrayList<>();
    // 记录左斜边、列、右斜边
    int left = 0, middle = 0, right = 0;
    process(0, n, left, middle, right, ans, new int[n]);
    return ans;
}
public void process(int layer, int n,
                    int left, int middle, int right,
                    List<List<String>> ans, int[] points){
    if(layer == n) {
        List<String> solve = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[points[i]] = 'Q';
            solve.add(new String(row));
        }
        ans.add(solve);
        return;
    }
    // 不能放的位置
    int limit = left | middle | right;
    for(int col = 0; col < n; col++){
        if(isValid(layer, n, col, limit)){
            points[layer] = col;
            int mask = 1 << (n - col - 1);
            process(layer + 1, n,
                    // 往下一层，左边界左移，保持一条左斜线上
                    (left | mask) << 1,
                    middle | mask,
                    // 右边界右移
                    (right | mask) >> 1,
                    ans, points);
        }
    }
}
public boolean isValid(int layer, int n, int col, int limit){
    // 只取有效位来判断
    limit = limit << (32 - n) >>> (32 - n);
    return ((limit >> (n - col - 1)) & 1) != 1 || limit == 0;
}
```

> 总结：贪心策略的选取，经验和积累很重要

# 初级-8

## 暴力递归

> 暴力递归就是尝试
> 1，把问题转化为规模缩小了的同类问题的子问题
> 2，有明确的不需要继续进行递归的条件(base case)
> 3，有当得到了子问题的结果之后的决策过程
> 4，**不记录每一个子问题的解** *（思路不要陷入递归里面）*

### 算法题

#### 1. 汉诺塔

> 1. 汉诺塔问题
>
> [力扣链接](https://leetcode-cn.com/problems/hanota-lcci/)

```java
public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
    move(A.size(), A, B, C);
}
public void move(int n, List<Integer> from, List<Integer> other, List<Integer> to){
    if (n <= 0) return;
    // 将n-1从from移到other
    move(n - 1, from, to, other);
    // 将第n个从from移到to
    to.add(from.remove(from.size() - 1));
    // 将n-1从other移到to
    move(n - 1, other, from, to);
}
```

#### 2. 打印子序列

> 2. 打印字符串所有子序列，包括空字符串

```java
// 对于字符串每个位置上的字符，有“要”和“不要”两条路
public void printAllSubstring(String str){
    process(0, str.toCharArray());
}
public void process(int index, char[] chars){
    if (index == chars.length) {
        printChars(chars);
        return;
    }
    process(index + 1, chars);
    char tmp = chars[index];
    chars[index] = 0;
    process(index + 1, chars);
    chars[index] = tmp;
}
public void printChars(char[] chars){
    StringBuilder sb = new StringBuilder(chars.length);
    for (char ch: chars){
        if (ch == 0) continue;
        sb.append(ch);
    }
    System.out.println(sb);
}
```

#### 3. 打印全排列

> 3. 打印全排列，且不允许出现重复

```java
public void printAllSorts(String str){
    process(0, str.toCharArray(), new char[str.length()], new boolean[str.length()]);
}
/**
 * 
 * @param index   当前索引
 * @param raw     原字符串
 * @param targets 目标字符串
 * @param visited 已尝试过的索引
 */
public void process(int index, char[] raw, char[] targets, boolean[] visited){
    if (index == raw.length) {
        printChars(targets);
        return;
    }
    // 不出现重复排列的机制
    boolean[] dupWord = new boolean[26];
    for (int i = 0; i < raw.length; i++){
        if (!visited[i] && !dupWord[raw[i] - 'a']){
            dupWord[raw[i] - 'a'] = true;
            targets[index] = raw[i];
            visited[i] = true;
            process(index + 1, raw, targets, visited);
            targets[index] = 0;
            visited[i] = false;
        }
    }
}
public void printChars(char[] chars){
    StringBuilder sb = new StringBuilder(chars.length);
    for (char ch: chars){
        if (ch == 0) continue;
        sb.append(ch);
    }
    System.out.println(sb);
}
```

优化，把不同的字符交换到索引位置，然后递归处理该位置后面的部分

```java
public void printAllSorts(String str){
    process(0, str.toCharArray());
}
public void process(int index, char[] raw){
    if (index == raw.length) {
        printChars(raw);
        return;
    }
    // 不出现重复排列的机制
    boolean[] dupWord = new boolean[26];
    for (int j = index; j < raw.length; j++){
        int temp;
        if (dupWord[(temp = raw[j] - 'a')]) continue;
        dupWord[temp] = true;
        swap(raw, index, j);
        process(index + 1, raw);
        swap(raw, index, j);
    }
}
public void swap(char[] chars, int x, int y){
    char temp = chars[x];
    chars[x] = chars[y];
    chars[y] = temp;
}
public void printChars(char[] chars){
    StringBuilder sb = new StringBuilder(chars.length);
    for (char ch: chars){
        if (ch == 0) continue;
        sb.append(ch);
    }
    System.out.println(sb);
}
```

> 这里用到的`if (dupWord[(temp = raw[j] - 'a')]) continue;`，就叫做分支限界，不满足条件的路就不走，提供一个限制，而不是在结果中再去清除

#### 4. 绝顶聪明

> 4. 绝顶聪明
>
> ![image-20210830204930010](imgs\左神算法课\13.png)

```java
public int win(int[] arr){
    return Math.max(first(arr, 0, arr.length - 1), second(arr, 0, arr.length - 1));
}
public int first(int[] arr, int l, int r){
    if (l == r) return arr[l];
    // 每次可以选左边或右边
    // 先手选左边，此时另一个人选，自己变成了后手
    int left = arr[l] + second(arr, l + 1, r);
    // 先手选右边
    int right = arr[r] + second(arr, l, r - 1);
    return Math.max(left, right);
}
public int second(int[] arr, int l, int r){
    if (l == r) return 0;
    int left = first(arr, l + 1, r);
    int right = first(arr, l, r - 1);
    // 为什么这里选最小？
    // 因为对方一定会留最差的结果给我
    return Math.min(left, right);
}
```

#### 5. 逆序栈

> 5. 逆序一个栈，不申请额外的数据结构，只用递归写法

```java
public void reverse(Stack<Integer> raw){
    if (raw.isEmpty()) return;
    int bottom = popBottom(raw);
    reverse(raw);
    raw.push(bottom);
}
// 移除栈底并返回
public int popBottom(Stack<Integer> raw){
    int result = raw.pop();
    if (raw.isEmpty()) return result;
    int last = popBottom(raw);
    raw.push(result);
    return last;
}
```

#### 6. 数字转字符串

> 6. 数字转字符串
>
> ![image-20210830215621196](imgs\左神算法课\14.png)

```java
public int transfer(String nums){
    return process(nums.toCharArray(), new char[nums.length()], 0);
}
public int process(char[] chars, char[] target, int index){
    if (index == chars.length){
        printChars(target);
        return 1;
    }
    // 无法组成任意一个
    if (chars[index] == '0') return 0;
    int result = 0;
    // 取第一个
    int takeOne = chars[index] - '1';
    target[index] = (char) ('A' + takeOne);
    result += process(chars, target, index + 1);
    target[index] = 0;
    // 取前两个
    if (index == chars.length - 1) return result;
    int takeTwo = Integer.parseInt("" + chars[index] + chars[index + 1]) - 1;
    if (takeTwo > 25) return result;
    target[index] = (char) ('A' + takeTwo);
    result += process(chars, target, index + 2);
    target[index] = 0;
    return result;
}
public void printChars(char[] chars){
    StringBuilder sb = new StringBuilder(chars.length);
    for (char ch: chars){
        if (ch == 0) continue;
        sb.append(ch);
    }
    System.out.println(sb);
}
```

如果只算结果，不打印

```java
public int transfer(String nums){
    return process(nums.toCharArray(), 0);
}
public int process(char[] chars, int index){
    if (index == chars.length){
        return 1;
    }
    // 无法组成任意一个
    if (chars[index] == '0') return 0;
    // 1的时候，两种情况都可以
    if (chars[index] == '1'){
        int res = process(chars, index + 1);
        if (index < chars.length - 1){
            res += process(chars, index + 2);
        }
        return res;
    }
    // 2的时候，得区分一下
    if (chars[index] == '2'){
        int res = process(chars, index + 1);
        char ch = chars[index];
        if (index < chars.length - 1 && (ch >= '0' && ch <= '6')){
            res += process(chars, index + 2);
        }
        return res;
    }
    // 3的时候，只能选一位
    return process(chars, index + 1);
}
```

#### 7. 最大价值

> 7. 最大价值
>
> ![image-20210831093858699](imgs\左神算法课\15.png)

```java
public int maxValue(int[] weights, int[] values, int bag){
    return process(weights, values, bag, 0);
}
public int process(int[] weights, int[] values, int bag, int index){
    if (index == weights.length || bag < 0) return 0;
    int max = 0;
    for (int j = index; j < weights.length; j++){
        swap(weights, index, j);
        // 记得一定要同时交换！
        swap(values, index, j);
        if (weights[index] <= bag){
            max = Math.max(values[index] + process(weights, values, bag - weights[index], index + 1)
                    , max);
        }
        swap(weights, index, j);
        swap(values, index, j);
    }
    return max;
}
public void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

简化版

```java
public int maxValue(int[] weights, int[] values, int bag){
    return process(weights, values, bag, 0);
}
public int process(int[] weights, int[] values, int bag, int index){
    if (index == weights.length || bag - weights[index] < 0) return 0;
    // 要这一个
    int get = values[index] + process(weights, values, bag - weights[index], index + 1);
    // 不要这一个
    int abandon = process(weights, values, bag, index + 1);
    return Math.max(get, abandon);
}
```

# 初级-9

## 哈希函数和哈希表

> 重要特性：均匀性、离散性

### 算法题

#### 1. 40亿大数统计

> 1. 40亿个0~40亿的数，统计哪个出现次数最多，要求4G内存内解决

基本思路：如果使用一个哈希表，要盛放这么多个数并计算最多，内存空间是远远不够的，于是有以下思路：

1. 设计数的hash方法
2. 遍历数据，散列到100个文件中（数量更多也可，只需满足每处理一个文件所需内存在4G内）
3. 统计每个文件中的最多的数字，统计一个文件完就释放内存
4. 比较所有文件中出现最多的数字

#### 2. 设计RandomPool

![image-20210831104919483](imgs\左神算法课\16.png)

基本思路：采用两个hashmap，分别映射index→key，key→index

```java
class RandomPool<Key>{
    private int size;
    private final HashMap<Integer, Key> index2keyMap;
    private final HashMap<Key, Integer> key2indexMap;
    public RandomPool(HashMap<Integer, Key> index2keyMap, HashMap<Key, Integer> key2indexMap) {
        this.index2keyMap = index2keyMap;
        this.key2indexMap = key2indexMap;
    }
    public RandomPool() {
        this(new HashMap<>(), new HashMap<>());
    }
    public void insert(Key key){
        if (key2indexMap.containsKey(key)) return;
        index2keyMap.put(size, key);
        key2indexMap.put(key, size++);
    }
    public void delete(Key key){
        if (key2indexMap.get(key) == null) return;
        int index = key2indexMap.get(key);
        Key last = index2keyMap.get(size - 1);
        // 用last去替换删去的那个，保证连续性
        index2keyMap.put(index, last);
        index2keyMap.remove(--size);
        key2indexMap.put(last, index);
        key2indexMap.remove(key);
    }
    public Key getRandom(){
        int randomSeed = new Random().nextInt(size);
        return index2keyMap.get(randomSeed);
    }
```

## 布隆过滤器

> 只有两种操作
>
> 1. 把某个元素加入一个超大集合
> 2. 确定该超大集合中包不包含某元素
>
> 不包括删除操作

> 场景：① 某个包含100亿url的网址黑名单，如何判断用户访问的网站在不在这个黑名单里面？② 爬虫去重；等等......

1. 所需内存少

2. 允许一定程度失误率

   > 某个本不在集合里的元素，可能判断成在集合里面；但如果集合中包括某个元素，不会判断成元素不在集合里面

   > 可通过人为设计极大降低失误率，但不可避免

### bitmap

> 数组的每个元素用一个bit来记录，比int型数组节省32倍的空间

具体实现，使用基本类型去拼凑，比如int[m]可以拼凑成bit[32*m]的数组

```java
class Bitmap{
    private int[] arr;
    private int length;
    public Bitmap(int capacity) {
        this.arr = new int[(this.length = 1 + (capacity >> 5))];
        this.length <<= 5;
    }
    // 获取某个索引的值
    public int get(int index){
        // 确定在int的哪个索引位置
        int arrIndex = index >> 5;
        // 确定bit位置
        int bitIndex = arr[arrIndex] >> index % 32;
        return bitIndex & 1;
    }
    // 改变某个索引的位置为1
    public void one(int index){
        int arrIndex = index >> 5;
        // 改为1
        arr[arrIndex] |= 1 << index % 32;
    }
    // 改变某个索引的位置为0
    public void zero(int index){
        int arrIndex = index >> 5;
        // 改为0
        arr[arrIndex] &= ~(1 << index % 32);
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++){
            sb.append(get(i) + " ");
        }
        return sb.toString();
    }
}
```

### 实现原理

首先需要一个长度为m的bit数组，和k个不同的哈希函数接着，以上面提到的黑名单场景为例

> 某个包含100亿url的网址黑名单，如何判断用户访问的网站在不在这个黑名单里面？

- 每添加一个url，使用k个不同的哈希函数计算出对应的$hash_{i(i=0,1,...,k)}$值，再通过$hash_i\%m$散列到bit数组的k个位置，将这k个位置从0改为1
- 每次判断的时候，通过同一组hash函数，计算k个位置上是不是都是1，如果是的话，则判断为黑名单
- 因此，有可能出现白名单被判断成黑名单的情况，但不会出现黑名单被判断成白名单，因为只要是黑名单，相应位置一定会是1，不可能是0

### 设计思路

`n`：样本量；`p`：理论失误率 ；`m`：bitmap长度；`k`：哈希函数个数

① 确定是否能用布隆过滤器；②给出期望失误率

- 公式一：$m=-\frac{n*lnp}{(ln2)^2}$，实际使用内存空间：$\frac{m}{8}$
- 公式二：$k=ln2*\frac{m}{n}≈0.7*\frac{m}{n}$
- 公式三：$p_真=(1-e^{-\frac{n*k_真}{m_真}})^{k_真}$

### 手动实现

> 尝试手写一个布隆过滤器

```java
@SuppressWarnings("all")
class BloomFilter<T>{
    final private Bitmap bitmap;
    // 哈希函数个数
    final private int k;
    // bitmap长度
    private int m;
    /**
     * @param n  样本量
     * @param p  期望失误率
     */
    public BloomFilter(int n, double p) {
        this.m = (int) (-(n * Math.log(p)) / (Math.log(2) * Math.log(2)));
        this.bitmap = new Bitmap(m);
        this.m = bitmap.length;
        this.k = (int) (0.7f * (m / n));
        System.out.println("bitmap长度: " + bitmap.length + "   需要哈希函数个数: " + k);
    }
    public BloomFilter() {
        this(1000000, 0.001);
    }
    // 超简易实现一组hash函数（实际不可取）
    public int hash(T o, int i){
        i += 999;
        int h;
        return (h = o.hashCode()) ^ (h >> 16) ^ Objects.hashCode(i ^ (i >> 2));
    }
    public void add(T o){
        for (int i = 0; i < k; i++){
            int h;
            int index = hash(o, i) % m;
            bitmap.one(index);
        }
    }
    public boolean contains(T o){
        for (int i = 0; i < k; i++){
            int h;
            int index = hash(o, i) % m;
            if (bitmap.get(index) == 0) return false;
        }
        return true;
    }
    @Override
    public String toString() {
        return bitmap.toString();
    }

    static class Bitmap{
        private final int[] arr;
        private int length;
        public Bitmap(int capacity) {
            this.arr = new int[(this.length = capacity >> 5)];
            this.length += capacity % 32 == 0 ? 0 : 1;
            this.length <<= 5;
        }
        // 获取某个索引的值
        public int get(int index){
            // 确定在int的哪个索引位置
            int arrIndex = index >> 5;
            // 确定bit位置
            int bitIndex = arr[arrIndex] >> index % 32;
            return bitIndex & 1;
        }
        // 改变某个索引的位置为1
        public void one(int index){
            int arrIndex = index >> 5;
            // 改为1
            arr[arrIndex] |= 1 << index % 32;
        }
        // 改变某个索引的位置为0
        public void zero(int index){
            int arrIndex = index >> 5;
            // 改为0
            arr[arrIndex] &= ~(1 << index % 32);
        }
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < length; i++){
                sb.append(get(i) + " ");
            }
            return sb.toString();
        }
    }
}
```

**测试结果**

```java
public static void main(String[] args) {
    BloomFilter<Integer> bloomFilter = new BloomFilter<>(1000000, 0.01);
    // 加入0~999999
    for (int i = 0; i < 1000000; i++){
        bloomFilter.add(i);
    }
    int t = 0, f = 0;
    // 500000~999999在内，1000000~1500000不在，比例应当是1：1
    for (int i = 500000; i < 1500000; i++){
        if (bloomFilter.contains(i)) ++t;
        else ++f;
    }
    System.out.println("true:false = " + t + ":" + f);
}
```

![image-20210901112033757](imgs\左神算法课\17.png)

### 扩展

google提供的布隆过滤器

> ```xml
> <dependency>
>     <groupId>com.google.guava</groupId>
>     <artifactId>guava</artifactId>
>     <version>29.0-jre</version>
> </dependency>
> ```
>
> ```java
> // params: 数据类型、预估元素数目、预估误判率
> BloomFilter bloomFilter 
>     = BloomFilter.create(Funnels.stringFunnel(StandardCharsets.UTF_8), 1000000, 0.01);
> bloomFilter.put("hello world");
> System.out.println(bloomFilter.mightContain("hello world"));
> ```

redis也提供布隆过滤器，用于处理缓存穿透

> ```tex
> 什么是缓存穿透？正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为缓存穿透。
> 
> 试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉
> 
> 解决思路：
> ① 缓存空值
>    之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。
> ② BloomFilter  
>    在缓存之前再加一层BloomFilter ，在查询的时候先去BloomFilter去查询key是否存在，如果不存在就直接返回，存在再走查缓存->查DB（BloomFilter中只放数据库中存在的数据，所以不可能将数据库中已存在的key的请求过滤掉，只可能会将不存在的key的请求判断为存在的从而放行，但概率很小，数据库完全能处理这种少量的放行）
> ```

## 一致性哈希

> 假设这样一个场景：数据存储采用分布式数据库服务，提供n个数据库服务器，可分为高频、中频、低频等
>
> 经典负载均衡的方法：
>
> - 插入一条数据例如（身份证号，姓名，...），采用hash函数计算出身份证号的哈希值，并%n，来确定放在哪一个数据库服务器
>
>   > 如果选取的参与哈希值计算的字段不具有区分性、或哈希函数设计不佳，可能会发生**数据倾斜**，即有的数据库服务器基本没有数据，无法做到均匀分布
>
> 如果增加或减少一台数据库服务器，则所有数据都要重新计算哈希并重新分配，是全量的，这就是经典方法的不足，**数据迁移代价太高**
>
> 如果是缓存服务器的话，大量缓存同时失效，查询请求堆积到后端服务器，造成系统崩溃，缓存雪崩

### 原理

为了解决上述问题，引入一致性哈希

首先，将hash值的域想象成一个环，0~2^32-1，一个无符号整型

![image-20210903112844729](imgs\左神算法课\18.png)

接着，假设有三台机器，为Node1，Node2，Node3，计算这三台机器的哈希并%2^32，映射到环上

> 参与计算hash值的数据可以是ip，也可以是主机的mac，反正尽量保持独特性

![image-20210903113107927](imgs\左神算法课\19.png)

存数据时，先计算数据哈希，再映射到环上，选取**顺时针最近**的服务器节点（可以用二分查找）来存储数据，比如对于数据A、B、C、D

![image-20210903114703881](imgs\左神算法课\20.png)

A存到Node2，B、C到Node3，D到Node1

此时，若增加一个机器

![image-20210903115030748](imgs\左神算法课\21.png)

只需要将B迁移到新Node，也就是数据库的部分迁移，而不是全量的，就不易造成很大代价

### 虚拟节点技术

不过上述仍存在问题，如果机器的hash在环上分配不均，势必会造成数据倾斜

于是，为每个数据库服务器Node分配若干个虚拟节点，计算他们的哈希并放到环上，数据插入时判断顺时针最近的虚拟节点属于哪个服务器，就存储到哪个服务器。虚拟节点的分配就比较均匀了，实际应用中一般选取大于32，对于能承受更高负载的节点，可以分配更多的虚拟节点

参考链接：

- [https://www.zsythink.net/archives/1182](https://www.zsythink.net/archives/1182)
- [https://www.cnblogs.com/lpfuture/p/5796398.html](https://www.cnblogs.com/lpfuture/p/5796398.html)

## 手写HashMap练习

## 手写阻塞队列练习



# 初级-10

## 并查集

提供两个操作：union(V1, V2)和isSameSet(V1, V2)

如果采用链表结构，操作一很容易，操作二则可能需要遍历整个链表

采用一种特殊的图结构：① 每个集合有一个代表节点；② 每个集合的代表节点有一个父节点

具体流程：

![image-20210911163619363](imgs\左神算法课\22.png)

查找isSameSet的次数越多，进行路径优化的次数就越多，当查找的次数接近样本数时，速度甚至可以逼近O(1)

```java
class UnionFindSet<V>{
    // 将用户输入的样本包装成Node
    private HashMap<V, Node<V>> valueMap = new HashMap<>();
    // 指向自己的父节点，也就是自己的代表节点
    private HashMap<Node<V>, Node<V>> fatherMap = new HashMap<>();
    // 代表节点，以及对应的集合的size
    private HashMap<Node<V>, Integer> sizeMap = new HashMap<>();
    public void add(V v){
        Node<V> node = new Node<>(v);
        valueMap.put(v, node);
        fatherMap.put(node, node);
        sizeMap.put(node, 1);
    }
    public void union(V v1, V v2){
        Node<V> v1Node, v2Node, v1F, v2F;
        int v1Size, v2Size;
        // 不处理没加入的样本
        if((v1Node = valueMap.get(v1)) == null || (v2Node = valueMap.get(v2)) == null) return;
        // 本就在一个集合中
        if((v1F = fatherMap.get(v1Node)) == (v2F = fatherMap.get(v2Node))) return;
        Node<V> newF = (v1Size = sizeMap.get(v1Node)) >= ((v2Size = sizeMap.get(v2Node))) ? v1F : v2F;
        fatherMap.remove(v1Node);
        fatherMap.remove(v2Node);
        fatherMap.put(v1Node, newF);
        fatherMap.put(v2Node, newF);
        sizeMap.remove(v1F);
        sizeMap.remove(v2F);
        sizeMap.put(newF, v1Size + v2Size);
    }
    public boolean isSameSet(V v1, V v2){
        return fatherMap.get(valueMap.get(v1)) != null
                && fatherMap.get(valueMap.get(v1)) == fatherMap.get(valueMap.get(v2));
    }
    static class Node<V> {
        V value;
        Node(V value) {
            this.value = value;
        }
    }
}
```

### 算法题

#### 1. 岛屿的数量

> 1. 岛屿的数量
>
> [力扣链接](https://leetcode-cn.com/problems/number-of-islands/)

首先想到的解法肯定是dfs

```java
public int numIslands(char[][] grid) {
    if(grid.length == 0) return 0;
    int rows = grid.length;
    int cols = grid[0].length;
    int res = 0;
    for(int i = 0; i < rows; i++){
        for(int j = 0; j < cols; j++){
            if(grid[i][j] == '1'){
                dfs(grid, i, j);
                ++res;
            }
        }
    }
    return res;
}
public void dfs(char[][] grid, int row, int col){
    if(row < 0 || col < 0 || row == grid.length || col == grid[0].length || grid[row][col] != '1') 
        return;
    grid[row][col]++;
    dfs(grid, row + 1, col);
    dfs(grid, row - 1, col);
    dfs(grid, row, col + 1);
    dfs(grid, row, col - 1);
}
```

实际上，可以采用并查集，提高效率

需要进行改写，用字符的位置作为元素加入并查集，而不是以字符本身，因为都是‘1’

```java
class Solution {
    public int numIslands(char[][] grid) {
        if(grid.length == 0) return 0;
        int rows = grid.length;
        int cols = grid[0].length;
        UnionFindSet set = new UnionFindSet(rows, cols);
        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                if (grid[i][j] == '1'){
                    set.add(cols, i, j);
                    if (i - 1 > 0 && grid[i - 1][j] == '1'){
                        set.add(cols, i - 1, j);
                        set.union(cols, i, j, i - 1, j);
                    }
                    if (j - 1 > 0 && grid[i][j - 1] == '1'){
                        set.add(cols, i, j - 1);
                        set.union(cols, i, j, i, j - 1);
                    }
                    if (i + 1 < rows && grid[i + 1][j] == '1'){
                        set.add(cols, i + 1, j);
                        set.union(cols, i, j, i + 1, j);
                    }
                    if (j + 1 < cols && grid[i][j + 1] == '1'){
                        set.add(cols, i, j + 1);
                        set.union(cols, i, j, i, j + 1);
                    }
                }
            }
        }
        return set.count();
    }
}
class UnionFindSet {
    int[] parent;
    int[] size;
    int count;
    public UnionFindSet(int row, int col) {
        parent = new int[row * col];
        Arrays.fill(parent, -1);
        size = new int[row * col];
    }
    public void add(int col, int x, int y){
        if (parent[x * col + y] != -1) return;
        parent[x * col + y] = x * col + y;
        size[x * col + y]++;
        count++;
    }
    public void union(int col, int x1, int y1, int x2, int y2){
        int v1 = x1 * col + y1;
        int v2 = x2 * col + y2;
        if (findParent(v1) == findParent(v2)) return;
        int big = Math.max(findParent(v1), findParent(v2));
        int small = Math.min(findParent(v1), findParent(v2));
        size[big] += size[small];
        size[small] = size[big];
        parent[small] = big;
        count--;
    }
    public int findParent(int v){
        while(v != parent[v]){
            v = parent[v];
        }
        return parent[v];
    }
    public int count(){
        return count;
    }
}
```

并查集可用于并行计算，最后处理边界即可

> 将大问题分割成小问题：map；最后合并处理：reduce，这就是mapReduce的实质

## KMP

看看一个字符串里面有没有给定的子串，并返回它的位置

fatherStr.indexOf(sonStr)

### 原理

#### 经典过程

![image-20210913093130333](imgs\左神算法课\23.png)

对于经典过程，遍历父字符串的每个位置，且最坏情况每次都需要匹配到子串末尾位置，设父串长度为n，子串长度为m，复杂度则为O(m*n)

#### KMP过程

首先，计算出子串每个位置的前面的字符串的前后缀相等（不算它本身）的最大长度，构成一个数组。数组第一位和第二位默认为-1，0

> 例如：对于abcdabce，对于e位置，它前面的字符串是abcdabc，前后缀相等的有a、ab、abc，最大长度为3
>
> 这个字符串对应的数组就是[-1, 0, 0, 0, 0, 1, 2, 3]

![image-20210913103737381](imgs\左神算法课\24.png)

**如何求解数组？**

![image-20210913105151778](imgs\左神算法课\25.png)

### 实现

1. 数组求解

```java
public int[] findArr(String str){
    int l = str.length();
    char[] chs = str.toCharArray();
    int[] arr = new int[l];
    arr[0] = -1;
    arr[1] = 0;
    for (int i = 2; i < l; i++) {
        char preChar = chs[i - 1];
        int preArrVal = arr[i - 1];
        while (preArrVal != -1 && preChar != chs[preArrVal]){
            preArrVal = arr[preArrVal];
        }
        arr[i] = preArrVal + 1;
    }
    return arr;
}
```

2. 算法流程

```java
public int indexOf(String fatherString, String sonString){
    int[] arr = findArr(sonString);
    int fl = fatherString.length(), sl = sonString.length();
    int fIndex = 0, sonIndex = 0;
    char[] fch = fatherString.toCharArray(), sch = sonString.toCharArray();
    while (fIndex < fl && sonIndex < sl){
        if (fch[fIndex] == sch[sonIndex]){
            ++fIndex;
            ++sonIndex;
        }else if(arr[sonIndex] == -1){
            ++fIndex;
        }else {
            sonIndex = arr[sonIndex];
        }
        if(sonIndex == sl) return fIndex - sl;
    }
    return -1;
}
```

**结合版本**

```java
public int[] findArr(String str){
    int l = str.length();
    char[] chs = str.toCharArray();
    int[] arr = new int[l];
    arr[0] = -1;
    arr[1] = 0;
    for (int i = 2; i < l; i++) {
        char preChar = chs[i - 1];
        int preArrVal = arr[i - 1];
        while (preArrVal != -1 && preChar != chs[preArrVal]){
            preArrVal = arr[preArrVal];
        }
        arr[i] = preArrVal + 1;
    }
    return arr;
}
public int indexOf(String fatherString, String sonString){
    int[] arr = findArr(sonString);
    int fl = fatherString.length(), sl = sonString.length();
    int fIndex = 0, sonIndex = 0;
    char[] fch = fatherString.toCharArray(), sch = sonString.toCharArray();
    while (fIndex < fl && sonIndex < sl){
        if (fch[fIndex] == sch[sonIndex]){
            ++fIndex;
            ++sonIndex;
        }else if(arr[sonIndex] == -1){
            ++fIndex;
        }else {
            sonIndex = arr[sonIndex];
        }
        if(sonIndex == sl) return fIndex - sl;
    }
    return -1;
}
```

## Manacher算法

### 原理

基于中心扩展算法，加速遍历扩展的过程

需要了解几个概念：

- 回文直径：某个字符能扩达到的最大回文串的直径

- 回文半径：某个字符能扩达到的最大回文串的半径

  > 如abcba，对于c，回文直径为5，回文半径为3

- 最大回文右边界：目前所有字符扩大到最大回文串后，最远的右边界r

  > 如babcbab，遍历到第一个a时，能扩到bab，最大右边界就是2；遍历到c时，能扩到babcbab，那么最大右边界就是6

- 最大回文右边界对应的中心c

  > 上面的例子，最大右边界为6，对应的中心为c，也就是3

#### 流程

主要目的就是，对一个字符串，从左往右求出它的最大回文半径数组，这样就自然而然能够知道字符串的最大回文子串

1. 改造字符串，如abc改造为#a#b#c#，这样便可以同时处理奇数和偶数回文串，结果的长度除以2即为结果

2. 遍历到某一处i，在最大回文右边界之外，暴力扩，并更新

3. 遍历到某一处i，在最大回文右边界之内，则找出i相对于c的对称点i'

   ![image-20210923094834700](imgs\左神算法课\27.png)

   1. i'的回文区域在最大回文区域之内，则i的回文半径等于i'的回文半径

   2. i'的回文区域在最大回文区域外，则i的回文半径等于i到r这一段。因为以i为中心，r右边的肯定不是回文，所以不用扩

   3. i'的回文区域的左边和最大回文区域正好压线，则i的回文半径从r开始往外扩。因为i到r这一段已经确定了，所以不用扩

      ![image-20210923100419907](imgs\左神算法课\28.png)

#### 伪代码

![image-20210922091347226](imgs\左神算法课\26.png)

### 实现

```java
public String longestPalindrome(String s) {
    int max = -1, maxIndex = -1;
    // 处理串
    int length;
    char[] processedStr = new char[1 + (s.length() << 1)];
    for (int i = 0; i < (length = processedStr.length) - 1; i++) {
        processedStr[i++] = '#';
        processedStr[i] = s.charAt(i >> 1);
    }
    processedStr[length - 1] = '#';

    // 回文半径数组
    int[] pal = new int[length];
    // 最大回文右边界及中心
    int r = -1, c = -1;
    for (int i = 0; i < length; i++) {
        if (i > r){
            int lo = i, hi = i;
            while (lo > 0 && hi < length - 1 && processedStr[lo - 1] == processedStr[hi + 1]){
                --lo;
                ++hi;
            }
            r = hi;
            c = i;
            pal[i] = r - c + 1;
        }else {
            int _i = (c << 1) - i;
            // i'的回文区域在最大回文区域内，则i的回文半径等于i'
            if (_i - pal[_i] > c - (r - c + 1)){
                pal[i] = pal[_i];
                // i'的回文区域在最大回文区域外，则i的回文半径等于i到r这一段
            }else if (_i - pal[_i] < c - (r - c + 1)){
                pal[i] = r - i + 1;
                // i'的回文区域的左边和最大回文区域正好压线，则i的回文半径从r开始往外扩
            }else {
                int lo = (i << 1) - r, hi = r;
                while (lo > 0 && hi < length - 1 && processedStr[lo - 1] == processedStr[hi + 1]){
                    --lo;
                    ++hi;
                }
                pal[i] = hi - i + 1;
                if (hi > r){
                    r = hi;
                    c = i;
                }
            }
        }

        // 判断最大
        if (pal[i] > max){
            max = pal[i];
            maxIndex = i;
        }
    }
    System.out.println(new String(processedStr));
    System.out.println(Arrays.toString(pal));
    StringBuilder sb = new StringBuilder();
    for (int i = maxIndex - max + 1; i < maxIndex + max; i++) {
        if (processedStr[i] == '#') continue;
        sb.append(processedStr[i]);
    }
    return sb.toString();
}
```

### 算法题

#### 1. 最长回文子串

> 给你一个字符串 `s`，找到 `s` 中最长的回文子串
>
> [力扣链接](https://leetcode-cn.com/problems/longest-palindromic-substring/)

1. 动态规划

```java
public String longestPalindrome(String s) {
    if(s == null || s == "" || s.length() == 1) return s;
    char[] chs = s.toCharArray();
    int l = chs.length, max = 0, left = 0, right = 0;
    boolean[][] dp = new boolean[l][l];
    for(int i = 0; i < l; i++){
        dp[i][i] = true;
    }
    for(int len = 2; len <= l; len++){
        for(int i = 0; i < l; i++){
            int j = i + len - 1;
            if(j >= l) break;
            else if(j == i + 1) dp[i][j] = chs[i] == chs[j];
            else dp[i][j] = dp[i + 1][j - 1] && chs[i] == chs[j];
            if(dp[i][j] && len > max) {
                max = len;
                left = i;
                right = j;
            }
        }
    }
    return s.substring(left, right + 1);
}
```

时间复杂度为O(N^2)，空间复杂度为O(N^2)，len为2时判断N-2次，为3时判读N-3次，为1+2+...+N-2 = O(N^2)

2. 中心扩展

```java
public String longestPalindrome(String s) {
    if(s == null || s == "" || s.length() == 1) return s;
    int l = s.length(), max = 0;
    String res = "";
    for(int i = 0; i < l; i++){
        String oneCenter = "", twoCenter = "";
        String substring = (oneCenter = expand(s, i, i)).length() > (twoCenter = expand(s, i, i + 1)).length() ? oneCenter : twoCenter;
        if(substring.length() > max){
            res = substring;
            max = substring.length();
        }
    }
    return res;
}
public String expand(String raw, int left, int right){
    while(left >= 0 && right < raw.length()){
        if(raw.charAt(left) == raw.charAt(right)){
            --left;
            ++right;
        }else break;
    }
    return raw.substring(++left, right);
}
```

注意双中心来处理偶数回文串的情况

时间复杂度为O(N^2)，空间复杂度为O(1)，最坏情况，每次都要扩展到边界

3. Manacher

> 解析如上

```java
public String longestPalindrome(String s) {
    int max = -1, maxIndex = -1;
    // 处理串
    int length;
    char[] processedStr = new char[1 + (s.length() << 1)];
    for (int i = 0; i < (length = processedStr.length) - 1; i++) {
        processedStr[i++] = '#';
        processedStr[i] = s.charAt(i >> 1);
    }
    processedStr[length - 1] = '#';

    // 回文半径数组
    int[] pal = new int[length];
    // 最大回文右边界及中心
    int r = -1, c = -1;
    for (int i = 0; i < length; i++) {
        if (i > r){
            int lo = i, hi = i;
            while (lo > 0 && hi < length - 1 && processedStr[lo - 1] == processedStr[hi + 1]){
                --lo;
                ++hi;
            }
            r = hi;
            c = i;
            pal[i] = r - c + 1;
        }else {
            int _i = (c << 1) - i;
            // i'的回文区域在最大回文区域内，则i的回文半径等于i'
            if (_i - pal[_i] > c - (r - c + 1)){
                pal[i] = pal[_i];
            // i'的回文区域在最大回文区域外，则i的回文半径等于i到r这一段
            }else if (_i - pal[_i] < c - (r - c + 1)){
                pal[i] = r - i + 1;
            // i'的回文区域的左边和最大回文区域正好压线，则i的回文半径从r开始往外扩
            }else {
                int lo = (i << 1) - r, hi = r;
                while (lo > 0 && hi < length - 1 && processedStr[lo - 1] == processedStr[hi + 1]){
                    --lo;
                    ++hi;
                }
                pal[i] = hi - i + 1;
                if (hi > r){
                    r = hi;
                    c = i;
                }
            }
        }

        // 判断最大
        if (pal[i] > max){
            max = pal[i];
            maxIndex = i;
        }
    }
    System.out.println(new String(processedStr));
    System.out.println(Arrays.toString(pal));
    StringBuilder sb = new StringBuilder();
    for (int i = maxIndex - max + 1; i < maxIndex + max; i++) {
        if (processedStr[i] == '#') continue;
        sb.append(processedStr[i]);
    }
    return sb.toString();
}
```

## 滑动窗口

### 算法题

#### 1. 窗口最大值

> 1. 窗口最大值
>
> ![image-20210923103113360](imgs\左神算法课\29.png)
>
> [力扣链接](https://leetcode-cn.com/problems/sliding-window-maximum/)

1. 可以用容量为窗口大小的堆，每次弹出一个，放进一个

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int index1 = 0, index2 = k - 1, resIndex = 0;
    if (index2 >= nums.length) return null;
    int[] res = new int[nums.length - index2];
    PriorityQueue<Integer> heap = new PriorityQueue<>(Comparator.reverseOrder());
    for (int i = index1; i <= index2; i++) {
        heap.offer(nums[i]);
    }
    res[resIndex++] = heap.peek();
    ++index2;
    while (index2 < nums.length){
        heap.remove(nums[index1++]);
        heap.offer(nums[index2++]);
        res[resIndex++] = heap.peek();
    }
    return res;
}
```

这种写法在力扣上会超时，改进，不用每次都急着删除，只要最大值的下标不在窗口范围内就删除即可

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int index1 = 0, index2 = k - 1, resIndex = 0;
    if (index2 >= nums.length) return null;
    int[] res = new int[nums.length - index2];
    PriorityQueue<int[]> heap = new PriorityQueue<>((o1, o2) -> o1[0] != o2[0] ? o2[0] - o1[0] : o2[1] - o1[1]);
    for (int i = index1; i <= index2; i++) {
        heap.offer(new int[]{nums[i], i});
    }
    res[resIndex++] = heap.peek()[0];
    ++index2;
    while (index2 < nums.length){
        heap.offer(new int[]{nums[index2], index2});
        while (heap.peek()[1] < index2 - k + 1){
            heap.poll();
        }
        res[resIndex++] = heap.peek()[0];
        ++index2;
    }
    return res;
}
```

2. 双端队列法（单调队列）

① 存下标，可以同时知道下标和数组对应的值；② 维持双端队列的头部一定是数组最大值；③ 每次从尾部插入，如果尾部小于要插入的值，则弹出尾部，保证队列里面是从头到尾递减的单调结构；④ 判断左边的下标，如果过期了（不在窗口范围），则弹出

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int limit = k - 1, resIndex = 0;
    if (limit >= nums.length) return null;
    int[] res = new int[nums.length - limit];
    Deque<Integer> deque = new LinkedList<>();
    for (int i = 0; i <= limit; i++) {
        while (!deque.isEmpty() && nums[i] >= nums[deque.getLast()]){
            deque.pollLast();
        }
        deque.addLast(i);
    }
    ++limit;
    res[resIndex++] = nums[deque.getFirst()];
    while (limit < nums.length) {
        // 弹出小的尾部
        while (!deque.isEmpty() && nums[limit] >= nums[deque.getLast()]){
            deque.pollLast();
        }
        deque.addLast(limit);
        // 去除过期下标
        while (deque.getFirst() < limit - k + 1) deque.pollFirst();
        res[resIndex++] = nums[deque.getFirst()];
        ++limit;
    }
    return res;
}
```

## 单调栈

### 原理

有这样一个场景：对于一个数组，求出它每个数左右两边最近的比它大的数

如果用遍历的方法，则是O(N^2)，于是有了O(N)的单调栈方法

遍历数组，假设遍历到i位置

1. i位置的数比栈顶元素对应位置的数小，直接将i入栈
2. 比栈顶大，不断弹出栈顶，直到满足第一个条件后入栈。**注意**，对于每一个弹出的元素p，收集信息，i即为p的右边的最近的比p大的数的下标；下一个栈顶即为p左边的最近的比p大的数的下标（如果下一个栈顶是合并的，则取最后一个）
3. 相等的，将它们合并
4. 遍历完成后栈中仍有元素，则全部弹出，右边最近的大于自己的数为空，左边则和上述一致

### 实现

```java
public int[][] findClosestBiggerNum(int[] arr){
    // 存放下标的单调栈
    Stack<ArrayList<Integer>> stack = new Stack<>();
    int[][] res = new int[arr.length][2];
    for (int i = 0; i < arr.length; i++) {
        // 比栈顶大，收集弹出元素的信息
        while (!stack.isEmpty() && arr[i] > arr[stack.peek().get(0)]){
            ArrayList<Integer> indexes = stack.pop();
            ArrayList<Integer> prev = stack.isEmpty() ? null : stack.peek();
            for (Integer index: indexes){
                res[index] = new int[]{prev == null ? -1 : prev.get(prev.size() - 1), i};
            }
        }
        ArrayList<Integer> temp;
        // 比栈顶小，直接入栈
        if (stack.isEmpty() || arr[i] < arr[stack.peek().get(0)]){
            temp = new ArrayList<>();
        // 相等，合并    
        }else {
            temp = stack.pop();
        }
        temp.add(i);
        stack.add(temp);
    }
    // 将剩余元素弹出并收集信息
    while (!stack.isEmpty()){
        ArrayList<Integer> indexes = stack.pop();
        ArrayList<Integer> prev = stack.isEmpty() ? null : stack.peek();
        for (Integer index: indexes){
            res[index] = new int[]{prev == null ? -1 : prev.get(prev.size() - 1), -1};
        }
    }
    return res;
}
```

**测试**

```java
public static void main(String[] args) {
    int[][] res = new Testt().findClosestBiggerNum(new int[]{5,4,3,6,7,1,3,8,3});
    for (int i = 0; i < res.length; i++){
        System.out.println(i + " -> " + Arrays.toString(res[i]));
    }
}
```

![image-20210923161028314](imgs\左神算法课\30.png)

### 算法题

[力扣链接](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)

TODO:后面补充

## 树型DP补充

### 算法题

#### 1. 叉树间最大节点距离

> 1. 最大节点距离
>
> ![image-20210924101753956](imgs\左神算法课\31.png)
>
> [力扣链接](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

最大距离一定是某一处节点的左右子树最大深度之和

```java
int ans = 0;
public int diameterOfBinaryTree(TreeNode root) {
    maxDepth(root);
    return ans;
}
public int maxDepth(TreeNode root){
    if(root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    ans = Math.max(ans, l + r);
    return 1 + Math.max(l, r);
}
```

按之前提到的递归套路，从左树要信息，从右树要信息的方式，需要哪些信息呢？

首先看各种可能性：

① 最大距离中包括头节点，那么最大距离就是左树的高+1+右树的高

② 最大距离中不包括头节点，则为左树的最大距离和右树的最大距离中较大的那一个

这样就清晰了，需要向左右树要他们的高度和最大距离的信息

```java
public int diameterOfBinaryTree(TreeNode root) {
    return process(root).maxDistance;
}
static class Info{
    int maxDistance;
    int height;
    Info(int maxDistance, int height){
        this.height = height;
        this.maxDistance = maxDistance;
    }
}
public Info process(TreeNode root){
    if(root == null){
        return new Info(0, 0);
    }
    Info fl = process(root.left);
    Info fr = process(root.right);
    int dl = fl.maxDistance;
    int dr = fr.maxDistance;
    int d = fl.height + fr.height;
    int maxd = Math.max(Math.max(dl, dr), d);
    int height = 1 + Math.max(fl.height, fr.height);
    return new Info(maxd, height);
}
```

小优化

```java
public int diameterOfBinaryTree(TreeNode root) {
    return process(root)[0];
}
public int[] process(TreeNode root){
    if(root == null){
        return new int[]{0, 0};
    }
    int[] fl = process(root.left);
    int[] fr = process(root.right);
    int dl = fl[0];
    int dr = fr[0];
    int d = fl[1] + fr[1];
    int maxd = Math.max(Math.max(dl, dr), d);
    int height = 1 + Math.max(fl[1], fr[1]);
    return new int[]{maxd, height};
}
```

#### 2. 派对最大快乐值

> 2. 派对最大快乐值
>
> ![image-20210924163008688](imgs\左神算法课\32.png)
>
> [牛客链接](https://www.nowcoder.com/practice/a5f542742fe24181b28f7d5b82e2e49a?tpId=101&tqId=33255&tPage=1&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

```java
import java.util.Scanner;
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int boss = in.nextInt();
        TreeNode[] nodes = new TreeNode[n];
        for(int i = 0; i < n; i++){
            nodes[i] = new TreeNode(in.nextInt());
        }
        for(int i = 0; i < n - 1; i++){
            nodes[in.nextInt() - 1].sons.add(in.nextInt() - 1);
        }
        TreeNode root = nodes[boss - 1];
        Info info = process(root, nodes);
        System.out.println(Math.max(info.maxHappyNotCome, info.maxHappyCome));
    }
    static class TreeNode{
        int happy;
        List<Integer> sons = new ArrayList<>();
        TreeNode(int happy){
            this.happy = happy;
        }
    }
    // ① 本节点参与
    //     本节点的快乐值+子节点不来情况下的最大快乐值
    // ① 本节点不参与
    //     子节点不来情况下的最大快乐值,子结点来的情况下的最大快乐值,两者中的最大值
    static class Info{
        int maxHappyNotCome;
        int maxHappyCome;
        Info(int maxHappyNotCome, int maxHappyCome){
            this.maxHappyNotCome = maxHappyNotCome;
            this.maxHappyCome = maxHappyCome;
        }
    }
    public static Info process(TreeNode node, TreeNode[] nodes){
        if(node.sons.size() == 0) return new Info(0, node.happy);
        int meNotCome = 0, meCome = node.happy;
        List<Integer> sons = node.sons;
        for(int i = 0; i < sons.size(); i++){
            Info sf = process(nodes[sons.get(i)], nodes);
            meCome += sf.maxHappyNotCome;
            meNotCome += Math.max(sf.maxHappyNotCome, sf.maxHappyCome);
        }
        return new Info(meNotCome, meCome);
    }
}
```

一个常用套路：包不包括该头节点，用这个来分类各种可能性

## Morris遍历

实现时间复杂度O(N)，空间复杂度O(1)的遍历（递归方法压栈时空间复杂度大于O(1)，因为递归会经过一个节点三次，递归栈以及其中的临时变量会一直留在那儿）

### 原理

用一个指针cur遍历整棵树

- 如果cur有左子树，则找到它的最右节点
  - 最右节点指向cur自己，则断开这一条指针，cur往右移
  - 最右指针为空，则令其指向cur，往左移动
- 如果cur没有左子树，向右移动

特征：有左树的节点可以到达两次，没有左树的节点只能到达一次

### 实现

```java
public void morris(TreeNode root){
    TreeNode cur = root;
    while (cur != null){
        System.out.print(cur.val + " ");
        if (cur.left != null){
            TreeNode mostRight = cur.left;
            while (mostRight.right != cur && mostRight.right != null) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
            }else {
                mostRight.right = null;
                cur = cur.right;
            }
        }else cur = cur.right;
    }
}
```

对于这样的树

![image-20210925110500949](imgs\左神算法课\34.png)

morris遍历结果是：![image-20210925110611776](imgs\左神算法课\35.png)

#### morris实现前序

只经过一次的节点打印；经过两次的节点，打印第一次

```java
public void preorderMorris(TreeNode root){
    TreeNode cur = root;
    while (cur != null){
        if (cur.left != null){
            TreeNode mostRight = cur.left;
            while (mostRight.right != cur && mostRight.right != null) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                // 两次经过的节点,第一次打印
                System.out.print(cur.val + " ");
                mostRight.right = cur;
                cur = cur.left;
            }else {
                mostRight.right = null;
                cur = cur.right;
            }
        }else {
            // 一次经过的节点,也就是没有左树,打印
            System.out.print(cur.val + " ");
            cur = cur.right;
        }
    }
}
```

#### morris实现中序

只经过一次的节点打印；经过两次的节点，打印第二次

```java
public void inorderMorris(TreeNode root){
    TreeNode cur = root;
    while (cur != null){
        if (cur.left != null){
            TreeNode mostRight = cur.left;
            while (mostRight.right != cur && mostRight.right != null) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
            }else {
                // 两次经过的节点,第二次打印
                System.out.print(cur.val + " ");
                mostRight.right = null;
                cur = cur.right;
            }
        }else {
            // 一次经过的节点,也就是没有左树,打印
            System.out.print(cur.val + " ");
            cur = cur.right;
        }
    }
}
```

#### morris实现后序

第二次经过的节点，逆序打印其左树的右边界；最后单独打印整棵树的右边界

```java
public void postMorris(TreeNode root){
    TreeNode cur = root;
    while (cur != null){
        if (cur.left != null){
            TreeNode mostRight = cur.left;
            while (mostRight.right != cur && mostRight.right != null) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
            }else {
                mostRight.right = null;
                // 第二次经过的节点，逆序打印其左树的右边界
                TreeNode curLeft = cur.left;
                TreeNode curLeftRightLimitTail = reverseRightLimit(curLeft);
                while (curLeftRightLimitTail != null){
                    System.out.print(curLeftRightLimitTail.val + " ");
                    curLeftRightLimitTail = curLeftRightLimitTail.right;
                }
                reverseRightLimit(curLeft);
                cur = cur.right;
            }
        }else cur = cur.right;
    }
    // 单独打印整棵树的右边界
    TreeNode rightLimitTail = reverseRightLimit(root);
    while (rightLimitTail != null){
        System.out.print(rightLimitTail.val + " ");
        rightLimitTail = rightLimitTail.right;
    }
    reverseRightLimit(root);
}

/**
 * 迭代反转右边界
 * @param node
 * @return
 */
public TreeNode reverseRightLimit(TreeNode node){
    if (node == null) return null;
    TreeNode curr, prev = null, pred = node;
    while (pred != null){
        curr = pred;
        pred = curr.right;
        curr.right = prev;
        prev = curr;
    }
    return prev;
}
```

# 初级-11

## 大数据问题

![image-20210926151040054](imgs\左神算法课\37.png)

### 算法题

#### 1. 统计没出现的数

> ![image-20210924222152894](imgs\左神算法课\33.png)

有40亿个数，如果用位图表示，0表示没出现过，1表示出现过，则需要4000000000 bit大小的数组，也就是500000000 Byte，也就是长度为125000000的int型数组，所占空间大小约为477 MB，1 GB足够了

遍历该40亿个数，并操作int型数组在不同位上的1或0，就可以找到所有没出现的数

**进阶**

范围缩小法+词频统计

- 整数的范围为0~2^32-1，有2^32个数，也就是说，可以等分成2^(32-n)个2^n的范围；可以用int型数组来记录每个范围内的数字个数
- 首先必须确保使用的内存小于10 MB，对于int型数组来说，10 MB可以构造长度为2621440的int型数组，2^21<2621440，也就是说，可以构造长度为2^21的int型数组，每个数组统计的范围长度为2^11，即分别统计出现在0~2047范围内的个数、2048~4095范围内的个数、...、2^32-2048~2^32-1范围内的个数
- 遍历40亿个数，令它除以2^11，确定在int数组内的下标，并令该下标处的元素+1；结束遍历后，如果有数组内元素没有达到2^11个，则该范围内一定有缺失值（词频统计）
- 任取一个有缺失值的范围，继续重复上述过程，最后总会找到一个缺失值（范围缩小）

#### 2. 找出重复URL

> ![image-20210926114805654](imgs\左神算法课\36.png)

想法1：遍历100亿个URL，不断加入布隆过滤器，加入之前先判断，如果已经在里面，则该URL为重复的。当然，可能会出现误判，将首次出现的URL判断为重复出现的

想法2：哈希分流，处理小文件，重复的URL经过hash分流一定会分流到一个文件当中

#### 3. 找出Top热词

> ![image-20210926152353960](imgs\左神算法课\38.png)

1. 先通过hash分流，将数据分别分流到若干个小文件中，用堆统计出每个文件的top 100词汇
2. 建立一个总堆，将所有文件最top的词汇插入堆中，并将这些词汇从源文件中删除
3. 从总堆中弹出一个词汇，找到弹出的这个词汇的源文件，从这个源文件的堆中弹出一条，插入总堆中建堆
4. 重复上述过程，直到弹出一百个，则为Top 100词汇

#### 4. 找到出现两次的数

> ![image-20210926152822550](imgs\左神算法课\39.png)

想法1：哈希分流，散列到各个小文件中，分别处理每个小文件，统计出现两次的数，最后将所有文件的结果汇聚到一起

想法2：用位图来记录，比如：用00来记录该数没有出现过，01表示出现一次，10表示出现2次，11表示出现2次以上

2^32个数，即需要2^33 bit = 2^30 Bytes = 2^20 KB = 2^10 MB = 1 GB

#### 5. 找出中位数

> ![image-20210926153106117](imgs\左神算法课\40.png)

进阶：将10MB改成10KB

采用范围缩小+词频统计

1. 词频统计采用int型数组，10 KB可以建立长度为2560的int型数组，因此，建立长度为2048的int型数组。对于2^32的数，数组的每个元素表示的范围分别是0~2^21-1，2^21~2^22-1，...，2^32-2^21~2^32-1
2. 遍历40亿个数，每次遇到0~2^21-1范围的，arr[0]++；2^21~2^22-1范围的，arr[1]++，依此类推，最后每个范围的词频被统计下来
3. 从第一个范围的词频开始，与后面的词频累加，累加到刚刚超过20亿时，就找到了该中位数的范围，比如：前m个词频之和为18亿，arr[m]的词频为5亿，加上去为23亿了，则中位数一定在arr[m]的范围内
4. 重复上述步骤，缩小范围，比如：将上面的arr[m]的范围均分，同样建立长度为2048的int型数组，再次遍历统计词频，并累加至刚刚过2亿（18亿+2亿=20亿）

#### 6. 大数据排序

> 腾讯二面原题：10亿条记录的大文件，包含若干个无序的int型数字，用5G的内存，完成对这些数的排序

想法一：范围缩小+词频统计+堆

1. 首先确定，int型数组的范围是-2^31~2^31-1，即范围大小2^32个数

2. 准备一个内存大小不超过5G的小根堆结构，用于记录若干组对应关系：数字-词频，数字代表int型数字，词频代表这个数出现的次数，每组原始结构需要8个字节，再加上其他一些额外结构的存储，假设需要16个字节。5G的内存空间，即5*2^30 Bytes，最接近的2次幂为2^32 Bytes，也就是说，一个5G的文件，最多可以放置一个有2^28条该记录的堆

   > ```java
   > public class Testt {
   >     public static void main(String[] args) {
   >         PriorityQueue<Record> heap = new PriorityQueue<>(Comparator.comparing(o -> o.number));
   >         loop: for (int i = 0; i < 100; i++) {
   >             Integer number = new Random().nextInt(100);
   >             for (Record temp : heap) {
   >                 if (number.equals(temp.number)) {
   >                     ++temp.times;
   >                     continue loop;
   >                 }
   >             }
   >             heap.add(new Record(number, 1));
   >         }
   >     }
   > }
   > class Record{
   >     Integer number;
   >     Integer times;
   >     public Record(Integer number, Integer times) {
   >         this.number = number;
   >         this.times = times;
   >     }
   > }
   > ```

3. 也就是说，每次可以处理2^28范围的数，因此，可以将-2^31~2^31-1分成16个范围，分别是

   -2^31~ -2^31+2^28-1，-2^31+2^28~-2^31+2^28，...

4. 遍历16次大文件，从数字小的范围开始每次处理一个范围内的数，遇到相同的数则词频+1，否则直接插入小根堆。处理完之后，从小根堆中弹出每条记录，并按词频数将数字输出到另一个文件，全部弹出后处理下一个范围，依此类推，得到的便是全部排序的数字

想法二：用大根堆来存储，首先遍历一遍，不断插入大根堆，当堆满后，大于大根堆堆顶的不插入，小于的插入，找出最小的2^28个，先处理；再根据上一次确定的大根堆堆顶m，不断将大于m的数字插入大根堆，重复上述处理，依此类推。少了一个计算范围的步骤

# 初级-12

## 位运算补充

### 算法题

#### 1. 比较大小

> ![image-20210926164359693](imgs\左神算法课\41.png)

```java
public int getMax(int n1, int n2){
    int c = n1 - n2;
    int sc_ = sign(c);
    int sc = flip(sc_);
    // c为负，n1 < n2，sc_为1，sc为0
    // c为正，n1 > n2，sc_为0，sc为1
    // sc、sc_为互斥的
    return sc * n1 + sc_ * n2;
}
public int sign(int number){
    return (number >> 31) & 1;
}
public int flip(int sign){
    return sign ^ 1;
}
```

但是，还要考虑溢出的情况

```java
public int getMax(int n1, int n2){
    int c = n1 - n2;
    int s1 = sign(n1);
    int s2 = sign(n2);
    int sc = sign(c);
    // n1、n2符号一样为0，不一样为1
    int s1DifS2 = s1 ^ s2;
    // n1、n2符号一样为1，不一样为0
    int s1SameS2 = flip(s1DifS2);
    // 返回n1的条件：① n1、n2符号一致，sc = 0；② 符号不一致，s1 = 0
    int return1 = s1DifS2 * flip(s1) + s1SameS2 * flip(sc);
    int return2 = flip(return1);
    return return1 * n1 + return2 * n2;
}
public int sign(int number){
    return (number >> 31) & 1;
}
public int flip(int sign){
    return sign ^ 1;
}
```

#### 2. 2的幂

![image-20210927210224998](imgs\左神算法课\42.png)

```java
public boolean judge2(int number){
    if (number <= 0) return false;
    return ((number - 1) & number) == 0;
}
```

判断4时，首先判断是否只有一个1，接着，再与0101 0101 0101 0101 0101 0101 0101 0101相与，看结果是否为0

```java
public boolean judge4(int number){
    if (number <= 0) return false;
    return (number & (number - 1)) == 0  && (number & 0x55555555) != 0;
}
```

#### 3. 不用加减乘除符号实现加减乘除

> 3. 不用加减乘除符号实现加减乘除

- 加

```java
public int add(int n1, int n2){
    // 无进位相加+进位信息即为求得的结果
    // 进位信息通过两数相与，左移一位来确定
    // 进位信息总会等于0的，于是总能直接返回异或的结果，而不需要真正将它与进位信息相加
    int addWithoutCarry = n1 ^ n2, carry = (n1 & n2) << 1;
    while (carry != 0){
        n1 = addWithoutCarry;
        addWithoutCarry ^= carry;
        carry = (n1 & carry) << 1;
    }
    return addWithoutCarry;
}
```

- 减

```java
public int sub(int n1, int n2){
    return add(n1, neg(n2));
}
public int neg(int number){
    return add(~number, 1);
}
```

- 乘

```java
/**
 * 以5*3为例
 *     0101
 *     0011
 * ----------
 *     0101
 *    0101
 *   0000
 *  0000
 *  0001111
 *  可以看出，遇到1，就将第一个数左移并与之前相加；遇到0，直接左移
 * @param n1
 * @param n2
 * @return
 */
public int multi(int n1, int n2){
    int sum = 0;
    while (n2 != 0){
        if ((n2 & 1) == 1){
            sum = add(sum, n1);
        }
        n1 <<= 1;
        n2 >>>= 1;
    }
    return sum;
}
```

- 除

```java
/**
 * 以51/3为例
 * 相当于乘法的逆运算
 *      110011
 *   ➗ 000011
 *   -----------
 *   110011-110000>=0,res=1
 *   000011-011000<0,res=10
 *   000011-001100>=0,res=100
 *   000011-000110<0,res=1000
 *   000011-000011>=0,res=10001
 * @param n1
 * @param n2
 * @return
 */
public int div(int n1, int n2){
    int x, y, res = 0, rawN2;
    x = n1 < 0 ? neg(n1) : n1;
    y = n2 < 0 ? neg(n2) : n2;
    rawN2 = y;
    while (y << 1 > 0){
        y <<= 1;
    }
    while (y >= rawN2){
        res <<= 1;
        if (sub(x, y) >= 0) {
            res |= 1;
            x = sub(x, y);
        }
        y >>>= 1;
    }
    return (n1 ^ n2) < 0 ? neg(res) : res;
}
```

# 初级-13

## 暴力递归→动态规划

套路：递归→记忆化搜索→动态规划

动态规划：①找到可变状态；②找到最终状态；③标出不用计算直接出答案的位置；④计算普遍位置；⑤确定顺序

### 算法题

#### 1. 机器人走直线

> 1. 机器人走直线
>
>    假设有排成一行的N个位置，记为1~N，N一定大于或等于2;
>    开始时机器人在M（1 <= M <= N）位置上，
>    如果机器人位于1位置，那么下一步只能走到2位置，
>    如果机器人位于N位置，那么下一步只能走到N-1位置，
>    如果机器人位于中间的任一位子，那么下一步可以向左走，也可以向右走。
>    机器人必须走K步，最终来到P（1 <= P <= N），给定参数N，M，K，P，有多少种走法？

1. 暴力递归

```java
public int walk(int N, int M, int K, int P){
    return process(N, M, K, P);
}
public int process(int N, int M, int K, int P){
    if (M > N || M < 1) return 0;
    if (K == 0){
        return P == M ? 1 : 0;
    }
    return process(N, M + 1, K - 1, P) + process(N, M - 1, K - 1, P);
}
```

递归的一大缺陷：重复递归

需要有个记录，记下已经计算过的递归过程的结果

总共K步，每步两个选择，O(2^K)

2. 记忆化搜索

注意到，可变状态只有M和K，且每一个可变状态的结果都不受之前的影响（每一个相同的递归都会返回同样的结果）

因此，给可变状态创建一个表，记录下处理过的它们的值，下次再遇到相同的可变状态，则直接从表中取出

```java
public int walk(int N, int M, int K, int P){
    // M范围为1~N，K的范围为0~K
    int[][] changeableStatus_M_K = new int[N + 1][K + 1];
    for (int i = 0; i < N + 1; i++) {
        for (int j = 0; j < K + 1; j++) {
            changeableStatus_M_K[i][j] = -1;
        }
    }
    return process(N, M, K, P, changeableStatus_M_K);
}
public int process(int N, int M, int K, int P, int[][] dp){
    if (M > N || M < 1) {
        return 0;
    }
    // 这一步，记录了递归的结果，节省了递归次数
    if (dp[M][K] != -1){
        return dp[M][K];
    }
    if (K == 0){
        dp[M][K] = M == P ? 1 : 0;
        return dp[M][K];
    }
    dp[M][K] = process(N, M - 1, K - 1, P, dp)
            + process(N, M + 1, K - 1, P, dp);
    return dp[M][K];
}
```

每个格子只计算一次，O(K*M)，记忆化搜索，只是一个缓存的作用

3. 动态规划

进一步看，以K作为行索引的话，第一行即K=0时，只有M==P才会为1，其他位置都为0

而下一行，K=1时，每一行的值是它左右上角的值相加，就像刚刚的递归一样

```java
dp[M][K] = process(N, M - 1, K - 1, P, dp)
            + process(N, M + 1, K - 1, P, dp);
```

因此，改进为动态规划

```java
public int walk(int N, int M, int K, int P){
    int[][] dp = new int[K + 1][N + 1];
    // 处理第一行
    for (int j = 1; j < N + 1; j++) {
        dp[0][j] = j == P ? 1 : 0;
    }
    // 后面的行
    for (int i = 1; i < K + 1; i++) {
        for (int j = 1; j < N + 1; j++) {
            dp[i][j] = (j == 1 ? 0 : dp[i - 1][j - 1])
                    + (j >= N ? 0 : dp[i - 1][j + 1]);
        }
    }
    return dp[K][M];
}
```

#### 2. 零钱兑换

> 2. 零钱兑换
>
> 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。
>
> 示例 1：
>
> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1
>
> [力扣链接](https://leetcode-cn.com/problems/coin-change)

1. 暴力递归

```java
public int coinChange(int[] coins, int amount) {
    cache = new int[amount];
    return process(coins, amount);
}
public int process(int[] coins, int amount){
    if(amount < 0) return -1;
    if(amount == 0) {
        return 0;
    }
    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        int p = 1 + process(coins, amount - coin);
        res = p != 0 ? Math.min(res, p) : res;
    }
    return res == Integer.MAX_VALUE ? -1 : res;
}
```

在力扣会超时，改进记忆化搜索

2. 记忆化搜索

```java
int[] cache;
public int coinChange(int[] coins, int amount) {
    cache = new int[amount];
    return process(coins, amount);
}
public int process(int[] coins, int amount){
    if(amount < 0) return -1;
    if(amount == 0) {
        return 0;
    }
    if(cache[amount - 1] != 0) return cache[amount - 1];
    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        int p = 1 + process(coins, amount - coin);
        res = p != 0 ? Math.min(res, p) : res;
    }
    cache[amount - 1] = res == Integer.MAX_VALUE ? -1 : res;
    return cache[amount - 1];
}
```

3. 动态规划

可变状态只有一个，即amount

```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    dp[0] = 0;
    for (int i = 1; i < amount + 1; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int coin: coins){
            dp[i] = (i - coin < 0 || dp[i - coin] == -1) ? dp[i] : Math.min(1 + dp[i - coin], dp[i]);
        }
        dp[i] = dp[i] == Integer.MAX_VALUE ? -1 : dp[i];
    }
    return dp[amount];
}
```

#### 3. 石头游戏（同初级-8中的''绝顶聪明''）

> 4. 石头游戏
>
> ![image-20211008092006202](imgs\左神算法课\43.png)
>
> [力扣链接](https://leetcode-cn.com/problems/stone-game/)

1. 暴力递归

```java
public boolean stoneGame(int[] piles) {
    int n = piles.length;
    return first(piles, 0, n - 1) > second(piles, 0, n - 1);
}
public int first(int[] piles, int l, int r){
    if(l == r) return piles[l];
    int left = piles[l] + second(piles, l + 1, r);
    int right = piles[r] + second(piles, l, r - 1);
    return Math.max(left, right);
} 
public int second(int[] piles, int l, int r){
    if(l == r) return 0;
    int left = first(piles, l + 1, r);
    int right = first(piles, l, r - 1);
    return Math.min(left, right);
}
```

暴力递归在力扣的case会超时，改进

2. 记忆化搜索

先取数组左边，再取数组右边，和先取数组右边，再取数组左边，这两个结果是一致的，但实际上却递归了两次

```java
int[][] cache;
public boolean stoneGame(int[] piles) {
    int n = piles.length;
    cache = new int[n][n];
    return first(piles, 0, n - 1) > second(piles, 0, n - 1);
}
public int first(int[] piles, int l, int r){
    if(l == r) return piles[l];
    if(cache[l][r] != 0) return cache[l][r];
    int left = piles[l] + second(piles, l + 1, r);
    int right = piles[r] + second(piles, l, r - 1);
    return Math.max(left, right);
} 
public int second(int[] piles, int l, int r){
    if(l == r) return 0;
    int left = first(piles, l + 1, r);
    cache[l + 1][r] = left;
    int right = first(piles, l, r - 1);
    cache[l][r - 1] = right;
    return Math.min(left, right);
}
```

3. 动态规划

最后，基于记忆化搜索，改动态规划

```java
public boolean stoneGame(int[] piles) {
    int n = piles.length;
    int[][] first = new int[n][n];
    int[][] second = new int[n][n];
    // 注意观察规律，发现所有的dp过程都在对角线上进行
    for(int i = 0; i < n; i++){
        first[i][i] = piles[i];
    }
    for(int col = 1; col < n; col++){
        for(int row = 0, tempCol = col; tempCol < n; row++, tempCol++){
            first[row][tempCol] = Math.max(piles[row] + second[row + 1][tempCol], 
                                           piles[tempCol] + second[row][tempCol - 1]);
            second[row][tempCol] = Math.min(first[row + 1][tempCol], 
                                            first[row][tempCol - 1]);
        }
    }
    return first[0][n - 1] > second[0][n - 1];
}
```

> 动态规划时，注意建立空间感

#### 4. 骑士拨号器

> 4. 骑士拨号器
>
> ![image-20211008104314461](imgs\左神算法课\44.png)
>
> [力扣链接](https://leetcode-cn.com/problems/knight-dialer/)

1. 暴力递归

```java
public int knightDialer(int n) {
    int res = 0;
    for(int i = 0; i < 4; i++){
        for(int j = 0; j < 3; j++){
            res += process(n - 1, i, j);
        }
    }
    return res;
}
public int process(int n, int x, int y){
    if(x < 0 || x > 3 || y < 0 || y > 2 || (x == 3 && (y == 0 || y == 2)) || (x == 1 && y == 1 && n != 0)) 
        return 0;
    if(n == 0) return 1;
    return process(n - 1, x - 1, y - 2) + process(n - 1, x - 2, y - 1)
        + process(n - 1, x - 2, y + 1) + process(n - 1, x - 1, y + 2)
        + process(n - 1, x + 1, y - 2) + process(n - 1, x + 2, y - 1)
        + process(n - 1, x + 2, y + 1) + process(n - 1, x + 1, y + 2);
}
```

力扣会超时

2. 记忆化搜索

可以知道，当跳到某个号码上，给定n，它的组合数是可以缓存的，比如说某次跳到5了，此时n = 3，还有xx种可能性，下次再遇到相同的情况，就可以直接从缓存中返回

```java
int[][][] cache;
public int knightDialer(int n) {
    cache = new int[n][4][3];
    int res = 0;
    for(int i = 0; i < 4; i++){
        for(int j = 0; j < 3; j++){
            res += process(n - 1, i, j);
        }
    }
    return res;
}
public int process(int n, int x, int y){
    if (x < 0 || x > 3 || y < 0 || y > 2 || (x == 3 && (y == 0 || y == 2)) || (x == 1 && y == 1 && n != 0)) 
        return 0;
    if (n == 0) return 1;
    if (cache[n - 1][x][y] != 0) return cache[n - 1][x][y];
    int res = process(n - 1, x - 1, y - 2) + process(n - 1, x - 2, y - 1)
        + process(n - 1, x - 2, y + 1) + process(n - 1, x - 1, y + 2)
        + process(n - 1, x + 1, y - 2) + process(n - 1, x + 2, y - 1)
        + process(n - 1, x + 2, y + 1) + process(n - 1, x + 1, y + 2);
    cache[n - 1][x][y] = res;
    return res;
}
```

力扣还会超时

3. 动态规划

```java
public int knightDialer(int n) {
    final long MOD = 1000000007;
    long[][][] dp = new long[n][4][3];
    long res = 0;
    for (int i = 0; i < n; i++){
        for (int x = 0; x < 4; x++) {
            for (int y = 0; y < 3; y++) {
                long temp = 0;
                if ((n != 1 && x == 1 && y == 1) || (x == 3 && (y == 0 || y == 2))) continue;
                if (i == 0) {
                    dp[i][x][y] = 1;
                    temp += 1;
                }else {
                    if (x > 0 && y > 1) temp += dp[i - 1][x - 1][y - 2] % MOD;
                    if (x > 1 && y > 0) temp += dp[i - 1][x - 2][y - 1] % MOD;
                    if (x > 1 && y < 2) temp += dp[i - 1][x - 2][y + 1] % MOD;
                    if (x > 0 && y < 1) temp += dp[i - 1][x - 1][y + 2] % MOD;
                    if (x < 3 && y > 1) temp += dp[i - 1][x + 1][y - 2] % MOD;
                    if (x < 2 && y > 0) temp += dp[i - 1][x + 2][y - 1] % MOD;
                    if (x < 2 && y < 2) temp += dp[i - 1][x + 2][y + 1] % MOD;
                    if (x < 3 && y < 1) temp += dp[i - 1][x + 1][y + 2] % MOD;
                    dp[i][x][y] = temp;
                }
                if (i == n - 1) res += temp;
            }
        }
    }
    return (int) (res % MOD);
}
```

> 记得把递归写聪明些，减少可变状态，感觉这一题写的不是很聪明......

# 初级-14

## AVL树

### 旋转

每次插入，从节点向上寻找，判断是否平衡

#### 右单旋

右单旋用于处理LL插入方式，假设存在一棵树，如下，

![image](imgs\左神算法课\45.png)

现插入“A”节点，假如不进行旋转的话，树结构为下图，所以遍历过程也会检查哪里不平衡，检查到“C”节点和“G”节点的高度差大于1，而且插入节点“A”属于“E”节点左子树的左子树，于是进行右单旋

![image](imgs\左神算法课\46.png)

“C”节点右单旋即将“C”节点提高，原本它的父节点“E”则变为其右子节点，“C”节点原来的右子节点则变为其父节点“E”的左子节点。右单旋后的结果如下，重新达到了平衡

![image](imgs\左神算法课\47.png)

#### 左单旋

左单旋用于处理RR插入方式，假设存在一棵树，如下

![image](imgs\左神算法课\48.png)

现插入“I”节点，假如不进行旋转的话，树结构为下图，所以遍历过程也会检查哪里不平衡，检查到“C”节点和“G”节点的高度差大于1，而且插入节点“I”属于“E”节点的右子树的右子树，于是进行左单旋

![image](imgs\左神算法课\49.png)

“G”节点左单旋即将“G”节点提高，原本它的父节点“E”则变为其左子节点，“G”节点原来的左子节点则变为其父节点“E”的右子节点。左单旋后的结果如下，重新达到了平衡

![image](imgs\左神算法课\50.png)

#### 左右双旋

左右双旋用于处理LR插入方式，假设存在一棵树，如下

![image](imgs\左神算法课\51.png)

现插入“C”节点，假如不进行旋转的话，树结构为下图，遍历过程会检查哪里不平衡，检查到“B”节点和“G”节点的高度差大于1，而且插入节点“C”属于“E”节点的左子树的右子树，于是进行左右双旋

![image](imgs\左神算法课\52.png)

先以“D”节点为轴进行左单旋，结果为

![image](imgs\左神算法课\53.png)

再以“D”节点为轴进行右单旋，得到最终结果

![image](imgs\左神算法课\54.png)

#### 右左双旋

右左双旋用于处理RL插入方式，假设存在一棵树，如下

![image](imgs\左神算法课\55.png)

现插入“G”节点，假如不进行旋转的话，树结构为下图，遍历过程会检查哪里不平衡，检查到“C”节点和“H”节点的高度差大于1，而且插入节点“G”属于“E”节点的右子树的左子树，于是进行右左双旋

![image](imgs\左神算法课\56.png)

先以“F”节点为轴进行右单旋，结果为

![image](imgs\左神算法课\57.png)

再以“F”节点为轴进行左单旋，得到最终结果

![image](imgs\左神算法课\58.png)

> 作者：超人汪小建
> 链接：https://juejin.cn/post/6844903653795430413
> 来源：稀土掘金
> 著作权归作者所有

红黑树、SB树和AVL树的区别：判断平衡的标准不一样

如：SB树：叔叔节点的子树大小大于侄子节点的子树大小

### 手写AVL树练习

## 跳表

### 手写跳表练习

# 中级-1

## 滑动窗口

### 算法题

#### 1. 绳子覆盖（百度笔试）

> 1. 绳子覆盖
>
> ![image-20211021112554558](imgs\左神算法课\59.png)

滑动窗口法

```java
public int cover(int L, int[] points){
    if (L == 0) return 0;
    int max = Integer.MIN_VALUE;
    int left = 0, right = 0;
    while (right < points.length){
        while (right < points.length && points[right] - points[left] <= L) right++;
        max = Math.max(max, right - left);
        left++;
    }
    return max;
}
```

## 贪心之打表法

#### 1. 吃草

> 1. 吃草：两头聪明的牛吃草，每次只能吃4的次方根草，对于n份草，先吃完算赢，问：先手赢还是后手赢？
>

```java
public String eat(int n){
    // n == 0, second win
    // n == 1, first
    // n == 2, second
    // n == 3, first
    // n == 4, first, eat 4
    if (n < 5){
        return (n == 0 || n == 2) ? "后手" : "先手";
    }
    int base = 1;
    // 先手吃base份，对于剩下的n-base份，如果n-base份后手赢，就代表是n份的先手赢
    while (base <= n){
        if ("后手".equals(eat(n - base))) return "先手";
        if (base > n / 4) break;
        base <<= 2;
    }
    return "后手";
}
```

从1开始打表，发现按照”先后先先后“的顺序循环，即每个循环的0、2位置

```java
public String eat(int n){
    return (n % 5 == 0 || n % 5 == 2) ? "后手" : "先手";
}
```

> PS：贪心技巧之打表法：入参为int，出参为int，可以先用很傻的方法写，再用对数器的方法看结果找出规律，最后按规律来写

## 预处理

主要用到了很多前缀和的技巧

### 算法题

#### 1. 染色

> 1. 染色：对于由"G"、"R"组成的字符串，想让R全部在左边，G全部在右边，最少需要染色几次？
>
> 如：RRGRGG，需染色一次，变成RRRRGG

思路：将游标放在0位置，右边全染成G，即统计右边R的个数；将游标放在1位置，左边全染成R，统计左边G的个数，右边全染成G，统计右边R的个数；...；将游标放在n位置，左边全染成R，统计左边G的个数

```java
public int color(String str){
    char[] chs = str.toCharArray();
    int min = str.length();
    for (int i = 0; i <= str.length(); i++){
        min = Math.min(min, countG(chs, 0, i) + countR(chs, i, str.length()));
    }
    return min;
}
public int countR(char[] chs, int start, int end){
    int count = 0;
    for (int i = start; i < end; i++) {
        if (chs[i] == 'R') ++count;
    }
    return count;
}
public int countG(char[] chs, int start, int end){
    int count = 0;
    for (int i = start; i < end; i++) {
        if (chs[i] == 'G') ++count;
    }
    return count;
}
```

复杂度：O(N^2)，如何优化？利用前缀和，记录下每个游标对应的左边有多少个G，右边有多少个R

```java
public int color(String str){
    char[] chs = str.toCharArray();
    int[] left_G = new int[chs.length];
    int[] right_R = new int[chs.length];
    for (int i = 0; i < chs.length; i++) {
        left_G[i] = (i > 0 ? left_G[i - 1] : 0) + (chs[i] == 'G' ? 1 : 0);
    }
    for (int i = chs.length - 1; i >= 0; i--) {
        right_R[i] = (i < chs.length - 1 ? right_R[i + 1] : 0) + (chs[i] == 'R' ? 1 : 0);
    }
    int min = str.length();
    for (int i = 0; i <= chs.length; i++){
        min = Math.min(min, (i > 0 ? left_G[i - 1] : 0) + (i < chs.length ? right_R[i] : 0));
    }
    return min;
}
```

复杂度：O(N)

#### 2. 边为1的最大边长正方形

> 2. 边为1的最大正方形：找出边为1的最大正方形，并返回它的边长
>
> 如：![image-20211105143548525](imgs\左神算法课\60.png)

> 前置：
>
> 1. 枚举所有矩形，复杂度为多少？
>
>    O(N^4)，因为任选一个点的复杂度为O(N^2)，任选两个点可对角组成一个矩形，所以为O(N^4)
>
> 2. 枚举所有正方形，复杂度为多少？
>
>    O(N^3)，因为任选一个点的复杂度为O(N^2)，将这个点作为左上角点，延展边，每个点的可能性不超过O(N)，因此为O(N^3)

```java
public int findMax(int[][] matrix){
    int rows = matrix.length;
    int cols = matrix[0].length;
    int max = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == 0) continue;
            int l = 1;
            // 枚举所有节点，然后延展边
            loop: for (; i + l < rows && j + l < cols; l++) {
                // 判断该长度是否可行
                // 向下扩展
                for (int k = i + 1; k <= i + l; k++) {
                    if (matrix[k][j] == 0) break loop;
                }
                // 向右扩展
                for (int k = j + 1; k <= j + l; k++) {
                    if (matrix[i][k] == 0) break loop;
                }
                int rightDown_r = i + l, rightDown_c = j + l;
                // 右上角向下扩展
                for (int k = i + 1; k <= i + l; k++) {
                    if (matrix[k][rightDown_c] == 0) break loop;
                }
                // 左下角向右扩展
                for (int k = j + 1; k <= j + l; k++) {
                    if (matrix[rightDown_r][k] == 0) break loop;
                }
            }
            max = Math.max(max, l);
        }
    }
    return max;
}
```

复杂度：O(N^4)

考虑采用前缀和优化，预先计算出每个点向右向下的最长连续1的个数

```java
public int findMax(int[][] matrix){
    /**
     *     1  1  0  1  0
     *     1  0  1  1  1
     *     0  0  1  0  1    返回 3
     *     1  1  1  1  1
     *     1  1  0  0  1
     */
    int rows = matrix.length;
    int cols = matrix[0].length;
    int[][] right = new int[rows][cols];
    int[][] down = new int[rows][cols];
    for (int i = rows - 1; i >= 0; i--){
        for (int j = cols - 1; j >= 0; j--) {
            right[i][j] = (j < cols - 1 ? right[i][j + 1] : 0) + matrix[i][j];
            down[i][j] = (i < rows - 1 ? down[i + 1][j] : 0) + matrix[i][j];
        }
    }
    int max = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == 0) continue;
            int l = 1;
            // 枚举所有节点，然后延展边
            for (; i + l < rows && j + l < cols; l++) {
                if (right[i][j] - 1 < l || down[i][j] - 1 < l) break;
                int rightDown_r = i + l, rightDown_c = j + l;
                if (down[rightDown_r][j] - 1 < l || right[i][rightDown_c] - 1 < l) break;
            }
            max = Math.max(max, l);
        }
    }
    return max;
}
```

复杂度：O(N^3)

## 拒绝采样

> 在拒绝采样中，如果生成的随机数满足要求，那么就返回该随机数，否则会不断生成，直到生成一个满足要求的随机数为止

### 算法题

#### 1. rand7→rand10

> 1. rand7→rand10
>
> ![image-20211108104156237](imgs\左神算法课\61.png)
>
> [力扣链接](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

1. 0-1生成器

```java
public int rand10() {
    // 0-9 0000~0101
    // 大于9的重做
    int res;
    do{
        res = row() + (row() << 1) + (row() << 2) + (row() << 3);
    }while(res > 9);
    return res + 1;
}
// 0-1发生器
public int row(){
    int res;
    do{
        res = rand7();
    }while(res == 4);
    return res < 4 ? 0 : 1;
}
```

2. 简单拒绝采样

```java
public int rand10() {
    int row, col, idx;
    do {
        row = rand7();
        col = rand7();
        idx = col + (row - 1) * 7;
    } while (idx > 40);
    return 1 + (idx - 1) % 10;
}
```

#### 1-2. 扩展

> 1-2. 扩展
>
> ![image-20211108104651382](imgs\左神算法课\62.png)

1. 热身：给定 f 可以返回1~5，给出g能够等概率返回0或1

思路：1-2返回0，3-4返回1，5重做

```java
public int g(){
    int f = f();
    if (1 == f || 2 == f) return 0;
    if (3 == f || 4 == f) return 1;
    return g();
}
```

另一种思路的写法

```java
public int g(){
    int res;
    do {
        res = f();
    }while (res == 3);
    return res < 3 ? 0 : 1;
}
```

1. 第一小题

思路：构建一个等概率返回0、1的，当作二进制位上的数

0~6，则为000~110，遇到111重做即可

再将0~6 + 1

```java
public int g(){
    int res;
    do {
        res = r() + (r() << 1) + (r() << 2);
    }while (res == 7);
    return res + 1;
}
public int r(){
    int res;
    do {
        res = f();
    }while (res == 3);
    return res < 3 ? 0 : 1;
}
```

2. 第二小题

```java
public int g(int c, int d){
    int digits = 0;
    while ((d - c) >> digits != 0) ++digits;
    int res;
    do {
        res = 0;
        for (int i = 0; i < digits; i++) {
            res += (row() << i);
        }
    }while (res > d - c);
    return res + c;
}
// 构建0-1生成器
public int row(){
    int res;
    int mid = a + ((b - a) >> 1);
    if ((b - a) % 2 == 0){
        do {
            res = f();
        }while (res == mid);
        return res < mid ? 0 : 1;
    }else {
        res = f();
        return res <= mid ? 0 : 1;
    }
}
```

3. 第三小题

思路：01概率=10概率=p*(1-p)

```java
public int row(){
    int res, x, y;
    do {
        x = f();
        y = f();
        res = x ^ y;
    }while (res == 0);
    return x == 0 ? 0 : 1;
}
```

# 中级-2

## 动态规划

### 算法题

#### 1. 不同的二叉树

> 1. 不同的二叉树
>
> ![image-20211111092844197](imgs\左神算法课\63.png)
>
> [力扣链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)

假设有N个节点，有：

一个根节点，右树N-1个节点，左树为空：f(N-1)

一个根节点，右树N-2个节点，左树1个节点：f(N-2)

一个根节点，右树N-3个节点，左树2个节点：f(N-3)*f(2)

......

一个根节点，右树N-1-i个节点，左树i个节点：f(N-i)*f(i-1)

将这些相加即为结果

```java
public int numTrees(int n) {
    if (n < 0) return 0;
    if (n == 0 || n == 1) return 1;
    if (n == 2) return 2;
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int j = n - 1 - i;
        sum += numTrees(i) * numTrees(j);
    }
    return sum;
}
```

改dp

```java
public int numTrees(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - 1 - j];
        }
    }
    return dp[n];
}
```

#### 2. 数字转字符串

> 2. 数字转字符串
>
> ![image-20211112102839120](imgs\左神算法课\68.png)
>
> [力扣链接](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

dp[i]，以i位置结尾，有多少种转换方式

dp[i-1]是肯定可以加上的，主要做好dp[i-2]能否加上的判断即可

```java
public int translateNum(int num) {
    if(num == 0) return 1;
    int digit = getDigit(num);
    int[] dp = new int[digit];
    dp[0] = 1;
    for (int i = 1; i < digit; i++){
        int n = getNumAt(num, i, digit);
        int preN = getNumAt(num, i - 1, digit);
        int temp = preN * 10 + n;
        dp[i] = dp[i - 1] + (preN != 0 && temp < 26 ? (i >= 2 ? dp[i - 2] : 1) : 0);
    }
    return dp[digit - 1];
}
public int getDigit(int num){
    int x = 1, y = 0;
    while (num / x != 0){
        x *= 10;
        ++y;
    }
    return y;
}
public int getNumAt(int num, int position, int digit){
    int x = digit - position;
    return (int) (num / Math.pow(10, x - 1)) % 10;
}
```

## 括号问题

### 算法题

#### 1. 完整括号

> 1. 完整括号
>
> ![image-20211111094858855](imgs\左神算法课\64.png)

首先解决一个小问题：如何判断括号是否完整？

```java
public boolean isValid(String str){
    char[] chs = str.toCharArray();
    int count = 0;
    for (char c: chs) {
        if (c == '(') ++count;
        else --count;
        // 如果count < 0, 表示左边有多余的')', 且无法被匹配
        if (count < 0) return false;
    }
    return count == 0;
}
```

添加括号令完整的话，分为两种情况：

① 出现count < 0，说明')'多了，需要添一个'('括号，令ans++，count++

② 结果count > 0，说明'('多了，需要添加count个')'

```java
public int add(String str){
    char[] chs = str.toCharArray();
    int count = 0, ans = 0;
    for (char c: chs) {
        if (c == '(') ++count;
        else --count;
        if (count < 0) {
            ++count;
            ++ans;
        }
    }
    return count + ans;
}
```

改进一下

```java
public int add(String str){
    char[] chs = str.toCharArray();
    int count = 0, ans = 0;
    for (char c: chs) {
        if (c == '(') ++count;
        else {
            if (count == 0) ++ans;
            else --count;
        }
    }
    return count + ans;
}
```

#### 2. 括号深度

> 2. 括号深度
>
> ![image-20211112093645646](imgs\左神算法课\66.png)

遇到'('，count++；遇到')'，count--，count最大值即为最大深度

```java
public int maxDepth(String str){
    char[] chs = str.toCharArray();
    int count = 0, max = 0;
    for (char ch: chs){
        if ('(' == ch) {
            ++count;
        } else {
            --count;
        }
        max = Math.max(max, count);
    }
    return max;
}
```

#### 3. 找到最长有效括号子串

> 3. 找到最长有效括号子串
>
> ![image-20211112094539054](imgs\左神算法课\67.png)

面对这种求子串类型的题，有一个技巧就是：求每一个位置必须分别作为结尾的情况下，最长的有效子串

```java
public int longestValidParentheses(String s) {
    int max = 0;
    char[] chs = s.toCharArray();
    for(int i = 1; i < chs.length; i++){
        int count = 0;
        for(int j = i; j >= 0; j--){
            if(')' == chs[j]) ++count;
            else --count;
            if(count < 0) break;
            if(count == 0) max = Math.max(i - j + 1, max);
        }
    }
    return max;
}
```

优化：dp，dp[i]表示以i结尾的最长有效子串是多少

```java
public int longestValidParentheses(String s) {
    int max = 0;
    int[] dp = new int[s.length()];
    char[] chs = s.toCharArray();
    for(int i = 1; i < chs.length; i++){
        // 如果以'('结尾，则一定不是有效子括号串
        if('(' == chs[i]) {
            dp[i] = 0;
        } else {
            // 如果以')'结尾，命名该')'为x
            int left = i - dp[i - 1] - 1;
            // dp[i-1]的左边小于0或者为')'，则无法找到与x相匹配的'('
            if(left < 0 || chs[left] == ')') {
                dp[i] = 0;
            } else {
                // 如果dp[i-1]的左边为'('，则至少为dp[i-1]+一对括号的长度，即+2
                // 此外，dp[i-1]的左边的左边可能接着一个有效的子括号串，需要把它加上
                // 例如
                //         ( ) ( ( ( ) ) )
                //  dp[i]  0 2 0 0 0 2 4 8(=dp[7]+2+dp[1])
                dp[i] += dp[i - 1] + 2 + (left > 0 ? dp[left - 1] : 0);
            }
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

## 贪心

### 算法题

#### 1. magic操作

> 1. magic操作
>
> ![image-20211111104055617](imgs\左神算法课\65.png)

```java
public int magicOps(Set<Integer> A, Set<Integer> B){
    int sumA = 0, sumB = 0;
    for (int a: A) sumA += a;
    for (int b: B) sumB += b;
    /**
     *  平均值相等时，无法做magic操作
     *    1. A向B移一个小于平均值的，B平均值下降
     *    2. A向B移一个等于平均值的，A平均值不变
     *    3. A向B移一个大于平均值的，A平均值下降
     */
    if (sumA == sumB && A.size() == B.size()) return 0;
    double avgA = avg(sumA, A.size()), avgB = avg(sumB, B.size());
    Set<Integer> big = avgA > avgB ? A : B;
    Set<Integer> small = big == A ? B : A;
    int sumBig = Math.max(sumA, sumB);
    int sumSmall = Math.min(sumA, sumB);
    double avgBig = Math.max(avgA, avgB);
    double avgSmall = Math.min(avgA, avgB);
    /**
     *   1. 只有从大的向小的移，才可能是magic操作，且只能移动avgSmall~avgBig范围，且小的里面没有的元素(可以自己举例证明)
     *   2. 每次从范围内选取最小的移动，能够保证avgSmall获得最小幅度的上升，avgBig获得最大幅度的上升，从而多进行几次magic操作
     */
    int ops = 0;
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    while (true){
        for (int b: big){
            if (!small.contains(b) && b > avgSmall && b < avgBig){
                heap.offer(b);
            }
        }
        if (heap.size() == 0) break;
        int num = heap.poll();
        big.remove(num);
        avgBig = avg(sumBig - num, big.size());
        small.add(num);
        avgSmall = avg(sumSmall + num, small.size());
        heap.clear();
        ++ops;
    }
    return ops;
}
```

#### 2. 有序矩阵中找数字

> 2. 有序矩阵中找数字
>
> ![image-20211112111550455](imgs\左神算法课\70.png)
>
> [力扣链接](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

从右上角开始找

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    int n = matrix.length;
    if(n == 0) return false;
    int m = matrix[0].length;
    int row = 0;
    while(true){
        if(m == 0 || row == n) return false;
        if(target == matrix[row][m - 1]) return true;
        else if(target > matrix[row][m - 1]) row++;
        else m--;
    }
}
```

#### 3. 超级洗衣机

> 3. 超级洗衣机
>
> ![image-20211112112709453](imgs\左神算法课\71.png)
>
> [力扣链接](https://leetcode-cn.com/problems/super-washing-machines/)

思路：

1. 首先对于每一个位置，计算出：

   1. 该位置左右都有多少个
   2. 该位置左右应该有多少个

2. 对于每一个位置，假设为i位置，用左右的现有值减去期望值，得到结果设为leftNeed、rightNeed

   1. 如果左右都为负数，表示左右两边的衣服都不够，需要i位置向两边补，至少需要|leftNeed+rightNeed|轮
   2. 如果左右都为正数，表示两边需要向i位置补，i位置可以一起接收，至少需要Math.max(|leftNeed|, |rightNeed|)轮
   3. 如果左负右正，表示从右补到i，再从i补到左，至少需要Math.max(|leftNeed|, |rightNeed|)轮
   4. 同上

3. 找到“最痛”的瓶颈，即需要轮数最多的，如果连这个瓶颈都解决了，其他的也解决了

   > 类似网络流量的各个瓶颈，最细的瓶颈过了，其他也能过

因此，有：

```java
public int findMinMoves(int[] machines) {
    int sum = 0;
    int[] preSum = new int[machines.length];
    for(int i = 0; i < machines.length; i++){
        sum += machines[i];
        if(i > 0) preSum[i] = preSum[i - 1] + machines[i - 1];
        else preSum[i] = 0;
    }
    if(sum % machines.length != 0) return -1;
    int max = 0, avg = sum / machines.length;
    for(int i = 0; i < machines.length; i++){
        int leftExpect = i * avg, rightExpect = (machines.length - i - 1) * avg;
        int leftNow = preSum[i], rightNow = sum - leftNow - machines[i];
        int leftNeed = leftNow - leftExpect, rightNeed = rightNow - rightExpect;
        if(leftNeed < 0 && rightNeed < 0){
            max = Math.max(max, Math.abs(leftNeed + rightNeed));
        }else{
            max = Math.max(max, Math.max(Math.abs(leftNeed), Math.abs(rightNeed)));
        }
    }
    return max;
}
```

## 二叉树

### 算法题

#### 1. 最大路径和

> 1. 最大路径和
>
> ![image-20211112111017346](imgs\左神算法课\69.png)
>
> [力扣链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```java
int max = Integer.MIN_VALUE;
public int maxPathSum(TreeNode root) {
    process(root);
    return max;
}
public int process(TreeNode root){
    if(root == null) return 0;
    int left = process(root.left);
    int right = process(root.right);
    // 返回时只能返回其中一条边，因为路径不能重复走
    int res = Math.max(root.val, Math.max(root.val + (left > 0 ? left : 0), root.val + (right > 0 ? right : 0)));
    // 判断时可以判断两条边
    max = Math.max(max, root.val + (left > 0 ? left : 0) + (right > 0 ? right : 0));
    return res;
}
```

# 中级-3

## 矩阵

### 算法题

> 不关注局部怎么变，设计宏观调度过程

#### 1. Z字形打印

#### 2. 螺旋打印

> 2. 螺旋打印
>
> ![image-20211115100127373](imgs\左神算法课\72.png)
>
> [力扣链接](https://leetcode-cn.com/problems/spiral-matrix/)

实现一个方法，根据左上角和右下角，顺时针打印所围起来的矩形边框

接着移动左上角和右下角，实现螺旋打印

不要去考虑每个局部怎么变的

```java
public List<Integer> spiralOrder(int[][] matrix) {
    int lur = 0, luc = 0, rdr = matrix.length - 1, rdc = matrix[0].length - 1;
    List<Integer> list = new ArrayList<>();
    while(luc <= rdc && lur <= rdr){
        printEdge(list, matrix, lur, luc, rdr, rdc);
        ++lur;
        ++luc;
        --rdr;
        --rdc;
    }
    return list;
}
public void printEdge(List<Integer> list, int[][] matrix, int lur, int luc, int rdr, int rdc){
    // 同行
    if(lur == rdr){
        for(int i = luc; i <= rdc; i++) list.add(matrix[lur][i]);
    // 同列
    }else if(luc == rdc){
        for(int i = lur; i <= rdr; i++) list.add(matrix[i][rdc]);
    // 标准情况
    }else{
        for(int i = luc; i <= rdc; i++) list.add(matrix[lur][i]);
        for(int i = lur + 1; i <= rdr; i++) list.add(matrix[i][rdc]);
        for(int i = rdc - 1; i >= luc; i--) list.add(matrix[rdr][i]);
        for(int i = rdr - 1; i > lur; i--) list.add(matrix[i][luc]);
    }
}
```

#### 3. 矩阵旋转

> 3. 矩阵旋转
>
> ![image-20211115105741494](imgs\左神算法课\73.png)
>
> [力扣链接](https://leetcode-cn.com/problems/rotate-image/)

1. 思路1：

每次处理一个边框（用两个角定位）

每个边框分多组处理

```java
public void rotate(int[][] matrix) {
    int firstRow = 0, firstCol = 0, lastRow = matrix.length - 1, lastCol = matrix[0].length - 1;
    while(firstRow <= lastRow){
        processEdge(matrix, firstRow, firstCol, lastRow, lastCol);
        ++firstRow;
        ++firstCol;
        --lastRow;
        --lastCol;
    }
}
public void processEdge(int[][] matrix, int firstRow, int firstCol, int lastRow, int lastCol){
    int group = lastRow - firstRow;
    int a = firstRow, b = firstCol;
    int c = firstRow, d = lastCol;
    int e = lastRow, f = lastCol;
    int g = lastRow, h = firstCol;
    while(group > 0){
        int temp = matrix[a][b];
        matrix[a][b] = matrix[g][h];
        matrix[g][h] = matrix[e][f];
        matrix[e][f] = matrix[c][d];
        matrix[c][d] = temp;
        ++b;
        ++c;
        --f;
        --g;
        --group;
    }
}
```

2. 思路2：

先沿中线左右翻转

再沿从左下到右上的对角线翻转

```java
public void rotate(int[][] matrix) {
    int n = matrix.length;
    for(int j = 0; j < n / 2; j++){
        for(int i = 0; i < n; i++){
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n - j - 1];
            matrix[i][n - j - 1] = temp;
        }
    }
    for(int i = 0; i < n - 1; i++){
        for(int j = 0; j < n - i - 1; j++){
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][n - i - 1];
            matrix[n - j - 1][n - i - 1] = temp;
        }
    }
}
```



# 



# 参考

[1] 左神算法课：[https://www.bilibili.com/video/BV16K4y157vm?p=1](https://www.bilibili.com/video/BV16K4y157vm?p=1)

[2] [https://www.zsythink.net/archives/1182](https://www.zsythink.net/archives/1182)[https://www.cnblogs.com/lpfuture/p/5796398.html](https://www.cnblogs.com/lpfuture/p/5796398.html)

[3] [https://www.cnblogs.com/lpfuture/p/5796398.html](https://www.cnblogs.com/lpfuture/p/5796398.html)

